--FUNCIONES TRANSACCIONALES Y DE INSERCION DE DATOS PARA LA TABLA TAB_PRUEBA------------------------------------------------------------------------------------------------------------
--FUNCION PARA VALIDAR LOS DATOS A INSERTAR EN LA TABLA PRUEBA
CREATE OR REPLACE FUNCTION FUN_VALIDAR_DATOS_PRUEBA(wNOM_PRUEBA TAB_PRUEBA.NOM_PRUEBA%TYPE,
                            wDESCRIPCION_PRUEBA TAB_PRUEBA.DESCRIPCION_PRUEBA%TYPE,wTIPO_PRUEBA TAB_PRUEBA.TIPO_PRUEBA%TYPE,
                            wFECHA_PRUEBA_INICIO TAB_PRUEBA.FECHA_PRUEBA_INICIO%TYPE,wFECHA_PRUEBA_FIN TAB_PRUEBA.FECHA_PRUEBA_FIN%TYPE,
                            wDURACION_PRUEBA_MINUTOS TAB_PRUEBA.DURACION_PRUEBA_MINUTOS%TYPE) RETURNS INTEGER AS
$$
    DECLARE
        RETORNO INTEGER;
    BEGIN
        --VALIDAR QUE EL NOMBRE DE LA PRUEBA NO SEA NULO
        IF wNOM_PRUEBA IS NULL THEN
            RETORNO := 5001;
            RETURN RETORNO;
        END IF;
        --VALIDAR QUE EL NOMBRE DE LA PRUEBA NO SEA VACIO
        IF wNOM_PRUEBA = '' THEN
            RETORNO := 5002;
            RETURN RETORNO;
        END IF;
        --VALIDAR QUE EL NOMBRE DE LA PRUEBA NO SEA MAYOR A 100 CARACTERES
        IF LENGTH(wNOM_PRUEBA) > 100 THEN
            RETORNO := 5003;
            RETURN RETORNO;
        END IF;
        --VALIDAR QUE LA DESCRIPCION DE LA PRUEBA NO SEA NULA
        IF wDESCRIPCION_PRUEBA IS NULL THEN
            RETORNO := 5004;
            RETURN RETORNO;
        END IF;
        --VALIDAR QUE LA DESCRIPCION DE LA PRUEBA NO SEA VACIA
        IF wDESCRIPCION_PRUEBA = '' THEN
            RETORNO := 5005;
            RETURN RETORNO;
        END IF;
        --VALIDAR QUE LA DESCRIPCION DE LA PRUEBA NO SEA MAYOR A 500 CARACTERES
        IF LENGTH(wDESCRIPCION_PRUEBA) > 500 THEN
            RETORNO := 5006;
            RETURN RETORNO;
        END IF;
        --VALIDAR QUE EL TIPO DE PRUEBA NO SEA NULO
        IF wTIPO_PRUEBA IS NULL THEN
            RETORNO := 5007;
            RETURN RETORNO;
        END IF;
        --VALIDAR QUE LA FECHA DE INICIO DE LA PRUEBA NO SEA NULA
        IF wFECHA_PRUEBA_INICIO IS NULL THEN
            RETORNO := 5008;
            RETURN RETORNO;
        END IF;
        --VALIDAR QUE LA FECHA DE FIN DE LA PRUEBA NO SEA NULA
        IF wFECHA_PRUEBA_FIN IS NULL THEN
            RETORNO := 5009;
            RETURN RETORNO;
        END IF;
        --VALIDAR QUE LA FECHA DE FIN DE LA PRUEBA SEA MAYOR A LA FECHA DE INICIO
        IF wFECHA_PRUEBA_FIN <= wFECHA_PRUEBA_INICIO THEN
            RETORNO := 5010;
            RETURN RETORNO;
        END IF;
        --VALIDAR QUE LA DURACION DE LA PRUEBA SEA MAYOR A 0
        IF wDURACION_PRUEBA_MINUTOS <= 0 THEN
            RETORNO := 5011;
            RETURN RETORNO;
        END IF;
        --SI PASA TODAS LAS VALIDACIONES RETORNAR 200
        RETORNO := 200;
        RETURN RETORNO;
    END;       
$$
LANGUAGE plpgsql;

--FUNCION PARA INSERTAR UNA PRUEBA GENERICA Y QUE RETORNE UN JSON CON EL RESULTADO, MENSAJE Y ID DE LA PRUEBA
CREATE OR REPLACE FUNCTION FUN_INSERTAR_PRUEBA_GENERICA_JSON(
    wNOM_PRUEBA TAB_PRUEBA.NOM_PRUEBA%TYPE,
    wDESCRIPCION_PRUEBA TAB_PRUEBA.DESCRIPCION_PRUEBA%TYPE,
    wTIPO_PRUEBA TAB_PRUEBA.TIPO_PRUEBA%TYPE,
    wFECHA_PRUEBA_INICIO TAB_PRUEBA.FECHA_PRUEBA_INICIO%TYPE,
    wFECHA_PRUEBA_FIN TAB_PRUEBA.FECHA_PRUEBA_FIN%TYPE,
    wDURACION_PRUEBA_MINUTOS TAB_PRUEBA.DURACION_PRUEBA_MINUTOS%TYPE,
    wNUMERO_PREGUNTAS TAB_PRUEBA.NUMERO_PREGUNTAS%TYPE,
    wID_AREA_PREGUNTAS_INSERTAR TAB_AREAS_EVALUAR.ID_AREA_EVALUAR%TYPE
) RETURNS JSON AS
$$
DECLARE
    RETORNO JSON;
    wVALIDAR INTEGER;
    ULTIMOID INTEGER;
    wID_PREGUNTA_RANDOM INTEGER;
    wCANTIDAD_PREGUNTAS_INSERTADAS INTEGER;
    wCANTIDAD_PREGUNTAS_TOTAL_AREA INTEGER;

    wFECHA_INICIO_COLOMBIA_BOGOTA TIMESTAMP;
    wFECHA_FIN_COLOMBIA_BOGOTA TIMESTAMP;
BEGIN
    -- Convertir las fechas a la zona horaria de Colombia
    wFECHA_INICIO_COLOMBIA_BOGOTA := (wFECHA_PRUEBA_INICIO::timestamptz AT TIME ZONE 'UTC') AT TIME ZONE 'America/Bogota';
    wFECHA_FIN_COLOMBIA_BOGOTA := (wFECHA_PRUEBA_FIN::timestamptz AT TIME ZONE 'UTC') AT TIME ZONE 'America/Bogota';
    -- VALIDACION DE LOS DATOS A INSERTAR
    wVALIDAR := FUN_VALIDAR_DATOS_PRUEBA(wNOM_PRUEBA, wDESCRIPCION_PRUEBA, wTIPO_PRUEBA, wFECHA_PRUEBA_INICIO, wFECHA_PRUEBA_FIN, wDURACION_PRUEBA_MINUTOS);
    IF wVALIDAR <> 200 THEN
        RETORNO := json_build_object('CODIGO', wVALIDAR, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = wVALIDAR));
        RETURN RETORNO;
    ELSE
        -- INICIAR TRANSACCION
        BEGIN
            -- OBTENER EL ULTIMO ID DE LA TABLA PRUEBA
            SELECT INTO ULTIMOID funcion_Retorna_ultmoid('TAB_PRUEBA', 'ID_PRUEBA');
            INSERT INTO TAB_PRUEBA(ID_PRUEBA, NOM_PRUEBA, DESCRIPCION_PRUEBA, TIPO_PRUEBA, FECHA_PRUEBA_INICIO, FECHA_PRUEBA_FIN, DURACION_PRUEBA_MINUTOS, NUMERO_PREGUNTAS)
            VALUES(ULTIMOID, wNOM_PRUEBA, wDESCRIPCION_PRUEBA, wTIPO_PRUEBA, wFECHA_INICIO_COLOMBIA_BOGOTA, wFECHA_FIN_COLOMBIA_BOGOTA, wDURACION_PRUEBA_MINUTOS, wNUMERO_PREGUNTAS);
            
            -- VERIFICAR SI SE REALIZO LA INSERCION
            IF FOUND THEN
                -- OBTENER LA CANTIDAD DE PREGUNTAS EN EL ÁREA A EVALUAR A TRAVÉS DE LOS TEMAS
                SELECT INTO wCANTIDAD_PREGUNTAS_TOTAL_AREA COUNT(*)
                FROM TAB_PREGUNTA P
                JOIN TAB_PREGUNTA_TEMAS PT ON P.ID_PREGUNTA = PT.ID_PREGUNTA
                JOIN TAB_TEMAS_AREAS TA ON PT.ID_TEMA_AREA = TA.ID_TEMA_AREA
                WHERE TA.ID_AREA_EVALUAR = wID_AREA_PREGUNTAS_INSERTAR;

                -- VERIFICAR QUE HAY SUFICIENTES PREGUNTAS DISPONIBLES
                IF wNUMERO_PREGUNTAS > wCANTIDAD_PREGUNTAS_TOTAL_AREA THEN
                    DELETE FROM TAB_PRUEBA WHERE ID_PRUEBA = ULTIMOID;
                    RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'No hay suficientes preguntas disponibles en el área evaluada');
                    RETURN RETORNO;
                END IF;

                -- INSERTAR LAS PREGUNTAS DE FORMA RANDOM
                wCANTIDAD_PREGUNTAS_INSERTADAS := 0;

                WHILE wCANTIDAD_PREGUNTAS_INSERTADAS < wNUMERO_PREGUNTAS LOOP
                    -- OBTENER UNA PREGUNTA RANDOM QUE AÚN NO HAYA SIDO INSERTADA
                    SELECT INTO wID_PREGUNTA_RANDOM P.ID_PREGUNTA
                    FROM TAB_PREGUNTA P
                    JOIN TAB_PREGUNTA_TEMAS PT ON P.ID_PREGUNTA = PT.ID_PREGUNTA
                    JOIN TAB_TEMAS_AREAS TA ON PT.ID_TEMA_AREA = TA.ID_TEMA_AREA
                    WHERE TA.ID_AREA_EVALUAR = wID_AREA_PREGUNTAS_INSERTAR
                    AND P.ID_PREGUNTA NOT IN (SELECT ID_PREGUNTA FROM TAB_PRUEBA_PREGUNTAS WHERE ID_PRUEBA = ULTIMOID)
                    ORDER BY RANDOM() LIMIT 1;

                    -- INSERTAR LA PREGUNTA EN LA PRUEBA
                    INSERT INTO TAB_PRUEBA_PREGUNTAS(ID_PRUEBA, ID_PREGUNTA) 
                    VALUES(ULTIMOID, wID_PREGUNTA_RANDOM);
                    wCANTIDAD_PREGUNTAS_INSERTADAS := wCANTIDAD_PREGUNTAS_INSERTADAS + 1;
                END LOOP;

                -- RETORNAR EL RESULTADO EXITOSO
                RETORNO := json_build_object('CODIGO', 200, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 200), 'DATOS', json_build_object('ID_PRUEBA', ULTIMOID));
                RETURN RETORNO;

            ELSE
                RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 1));
                RETURN RETORNO;
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                -- ELIMINAR LA PRUEBA SI OCURRE UN ERROR
                DELETE FROM TAB_PRUEBA WHERE ID_PRUEBA = ULTIMOID;
                RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'Error al insertar la prueba');
                RETURN RETORNO;
        END;
    END IF;
END;
$$
LANGUAGE plpgsql;




--FUNCION PARA INSERTAR UNA PRUEBA GENERICA Y QUE RETORNE UN JSON CON EL RESULTADO, MENSAJE Y ID DE LA PRUEBA
CREATE OR REPLACE FUNCTION FUN_INSERTAR_PRUEBA_GENERICA_TYT_JSON(
    wNOM_PRUEBA TAB_PRUEBA.NOM_PRUEBA%TYPE,
    wDESCRIPCION_PRUEBA TAB_PRUEBA.DESCRIPCION_PRUEBA%TYPE,
    wTIPO_PRUEBA TAB_PRUEBA.TIPO_PRUEBA%TYPE,
    wFECHA_PRUEBA_INICIO TAB_PRUEBA.FECHA_PRUEBA_INICIO%TYPE,
    wFECHA_PRUEBA_FIN TAB_PRUEBA.FECHA_PRUEBA_FIN%TYPE,
    wDURACION_PRUEBA_MINUTOS TAB_PRUEBA.DURACION_PRUEBA_MINUTOS%TYPE
) RETURNS JSON AS
$$
DECLARE
    RETORNO JSON;
    wVALIDAR INTEGER;
    ULTIMOID INTEGER;
    wID_PREGUNTA_RANDOM INTEGER;
    wCANTIDAD_PREGUNTAS_INSERTADAS INTEGER; -- Declaración de la variable
    wCANTIDAD_PREGUNTAS_TOTAL_AREA INTEGER;
    wNUMERO_PREGUNTAS INTEGER := 100;
    i INTEGER;
    wFECHA_INICIO_COLOMBIA_BOGOTA TIMESTAMP;
    wFECHA_FIN_COLOMBIA_BOGOTA TIMESTAMP;
BEGIN
    -- Convertir las fechas a la zona horaria de Colombia
    wFECHA_INICIO_COLOMBIA_BOGOTA := (wFECHA_PRUEBA_INICIO::timestamptz AT TIME ZONE 'UTC') AT TIME ZONE 'America/Bogota';
    wFECHA_FIN_COLOMBIA_BOGOTA := (wFECHA_PRUEBA_FIN::timestamptz AT TIME ZONE 'UTC') AT TIME ZONE 'America/Bogota';
    -- VALIDACION DE LOS DATOS A INSERTAR
    wVALIDAR := FUN_VALIDAR_DATOS_PRUEBA(wNOM_PRUEBA, wDESCRIPCION_PRUEBA, wTIPO_PRUEBA, wFECHA_PRUEBA_INICIO, wFECHA_PRUEBA_FIN, wDURACION_PRUEBA_MINUTOS);
    IF wVALIDAR <> 200 THEN
        RETORNO := json_build_object('CODIGO', wVALIDAR, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = wVALIDAR));
        RETURN RETORNO;
    ELSE
        -- INICIAR TRANSACCION
        BEGIN
            -- OBTENER EL ULTIMO ID DE LA TABLA PRUEBA
            SELECT INTO ULTIMOID funcion_Retorna_ultmoid('TAB_PRUEBA', 'ID_PRUEBA');
            INSERT INTO TAB_PRUEBA(ID_PRUEBA, NOM_PRUEBA, DESCRIPCION_PRUEBA, TIPO_PRUEBA, FECHA_PRUEBA_INICIO, FECHA_PRUEBA_FIN, DURACION_PRUEBA_MINUTOS, NUMERO_PREGUNTAS)
            VALUES(ULTIMOID, wNOM_PRUEBA, wDESCRIPCION_PRUEBA, wTIPO_PRUEBA, wFECHA_INICIO_COLOMBIA_BOGOTA, wFECHA_FIN_COLOMBIA_BOGOTA, wDURACION_PRUEBA_MINUTOS, wNUMERO_PREGUNTAS);
            
            -- VERIFICAR SI SE REALIZO LA INSERCION
            IF FOUND THEN
                -- VINCULAR PREGUNTAS A LA PRUEBA DE FORMA RANDOM TENIENDO EN CUENTA EL AREA A EVALUAR
                -- OBTENER LA CANTIDAD DE PREGUNTAS EN EL ÁREA A EVALUAR A TRAVÉS DE LOS TEMAS
                FOR i IN 1..4 LOOP
                    SELECT INTO wCANTIDAD_PREGUNTAS_TOTAL_AREA COUNT(*)
                    FROM TAB_PREGUNTA P
                    JOIN TAB_PREGUNTA_TEMAS PT ON P.ID_PREGUNTA = PT.ID_PREGUNTA
                    JOIN TAB_TEMAS_AREAS TA ON PT.ID_TEMA_AREA = TA.ID_TEMA_AREA
                    WHERE TA.ID_AREA_EVALUAR = i;

                    -- VERIFICAR QUE HAY SUFICIENTES PREGUNTAS DISPONIBLES
                    IF wNUMERO_PREGUNTAS / 4 > wCANTIDAD_PREGUNTAS_TOTAL_AREA THEN
                        -- ELIMINAR LA PRUEBA SI NO HAY SUFICIENTES PREGUNTAS
                        DELETE FROM TAB_PRUEBA WHERE ID_PRUEBA = ULTIMOID;
                        RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'No hay suficientes preguntas disponibles en el área evaluada', 'AREA', i);
                        RETURN RETORNO;
                    END IF; 

                    -- REINICIAR EL CONTADOR DE PREGUNTAS INSERTADAS PARA CADA ÁREA
                    wCANTIDAD_PREGUNTAS_INSERTADAS := 0;

                    -- INSERTAR LAS PREGUNTAS DE FORMA RANDOM
                    WHILE wCANTIDAD_PREGUNTAS_INSERTADAS < wNUMERO_PREGUNTAS / 4 LOOP
                        -- OBTENER UNA PREGUNTA RANDOM QUE AÚN NO HAYA SIDO INSERTADA
                        SELECT INTO wID_PREGUNTA_RANDOM P.ID_PREGUNTA
                        FROM TAB_PREGUNTA P
                        JOIN TAB_PREGUNTA_TEMAS PT ON P.ID_PREGUNTA = PT.ID_PREGUNTA
                        JOIN TAB_TEMAS_AREAS TA ON PT.ID_TEMA_AREA = TA.ID_TEMA_AREA
                        WHERE TA.ID_AREA_EVALUAR = i
                        AND P.ID_PREGUNTA NOT IN (SELECT ID_PREGUNTA FROM TAB_PRUEBA_PREGUNTAS WHERE ID_PRUEBA = ULTIMOID)
                        ORDER BY RANDOM() LIMIT 1;

                        -- INSERTAR LA PREGUNTA EN LA PRUEBA
                        INSERT INTO TAB_PRUEBA_PREGUNTAS(ID_PRUEBA, ID_PREGUNTA) 
                        VALUES(ULTIMOID, wID_PREGUNTA_RANDOM);
                        wCANTIDAD_PREGUNTAS_INSERTADAS := wCANTIDAD_PREGUNTAS_INSERTADAS + 1;
                    END LOOP;
                END LOOP;

                -- RETORNAR EL RESULTADO EXITOSO
                RETORNO := json_build_object('CODIGO', 200, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 200), 'DATOS', json_build_object('ID_PRUEBA', ULTIMOID));
                RETURN RETORNO;
            ELSE
                RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 1));
                RETURN RETORNO;
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                -- ELIMINAR LA PRUEBA SI OCURRE UN ERROR
                DELETE FROM TAB_PRUEBA WHERE ID_PRUEBA = ULTIMOID;
                RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'Error al insertar la prueba');
                RETURN RETORNO;
        END;
    END IF;
END;
$$
LANGUAGE plpgsql;


--FUNCION PARA CREAR UNA PRUEBA CUSTOMIZADA Y QUE RETORNE UN JSON CON EL RESULTADO, MENSAJE Y ID DE LA PRUEBA
CREATE OR REPLACE FUNCTION FUN_INSERTAR_PRUEBA_CUSTOMIZADA_JSON(
    wNOM_PRUEBA TAB_PRUEBA.NOM_PRUEBA%TYPE,
    wDESCRIPCION_PRUEBA TAB_PRUEBA.DESCRIPCION_PRUEBA%TYPE,
    wTIPO_PRUEBA TAB_PRUEBA.TIPO_PRUEBA%TYPE,
    wFECHA_PRUEBA_INICIO TAB_PRUEBA.FECHA_PRUEBA_INICIO%TYPE,
    wFECHA_PRUEBA_FIN TAB_PRUEBA.FECHA_PRUEBA_FIN%TYPE,
    wDURACION_PRUEBA_MINUTOS TAB_PRUEBA.DURACION_PRUEBA_MINUTOS%TYPE,
    wPREGUNTAS JSON
) RETURNS JSON AS
$$
DECLARE
    RETORNO JSON;
    wVALIDAR INTEGER;
    ULTIMOID INTEGER;
    wID_PREGUNTA INTEGER;
    wCANTIDAD_PREGUNTAS_INSERTADAS INTEGER;
    wCANTIDAD_PREGUNTAS_TOTAL_AREA INTEGER;
    wNUMERO_PREGUNTAS INTEGER;
    wID_PREGUNTA_JSON INTEGER;
    wID_PREGUNTA_ARRAY INTEGER[];
    wID_PREGUNTA_RANDOM INTEGER;
    wCANTIDAD_PREGUNTAS_JSON INTEGER;
    wCANTIDAD_PREGUNTAS_TOTAL INTEGER;
    i INTEGER;

    wFECHA_INICIO_COLOMBIA_BOGOTA TIMESTAMP;
    wFECHA_FIN_COLOMBIA_BOGOTA TIMESTAMP;
BEGIN
    -- Convertir las fechas a la zona horaria de Colombia
    wFECHA_INICIO_COLOMBIA_BOGOTA := (wFECHA_PRUEBA_INICIO::timestamptz AT TIME ZONE 'UTC') AT TIME ZONE 'America/Bogota';
    wFECHA_FIN_COLOMBIA_BOGOTA := (wFECHA_PRUEBA_FIN::timestamptz AT TIME ZONE 'UTC') AT TIME ZONE 'America/Bogota';

    -- VALIDACION DE LOS DATOS A INSERTAR
    wVALIDAR := FUN_VALIDAR_DATOS_PRUEBA(wNOM_PRUEBA, wDESCRIPCION_PRUEBA, wTIPO_PRUEBA, wFECHA_PRUEBA_INICIO, wFECHA_PRUEBA_FIN, wDURACION_PRUEBA_MINUTOS);
    IF wVALIDAR <> 200 THEN
        RETORNO := json_build_object('CODIGO', wVALIDAR, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = wVALIDAR));
        RETURN RETORNO;
    ELSE
        -- INICIAR TRANSACCION
        BEGIN
            -- OBTENER EL ULTIMO ID DE LA TABLA PRUEBA
            SELECT INTO ULTIMOID funcion_Retorna_ultmoid('TAB_PRUEBA', 'ID_PRUEBA');
            INSERT INTO TAB_PRUEBA(ID_PRUEBA, NOM_PRUEBA, DESCRIPCION_PRUEBA, TIPO_PRUEBA, FECHA_PRUEBA_INICIO, FECHA_PRUEBA_FIN, DURACION_PRUEBA_MINUTOS)
            VALUES(ULTIMOID, wNOM_PRUEBA, wDESCRIPCION_PRUEBA, wTIPO_PRUEBA, wFECHA_INICIO_COLOMBIA_BOGOTA, wFECHA_FIN_COLOMBIA_BOGOTA, wDURACION_PRUEBA_MINUTOS);
            
            -- VERIFICAR SI SE REALIZO LA INSERCION
            IF FOUND THEN
                -- OBTENER EL NUMERO DE PREGUNTAS
                wNUMERO_PREGUNTAS := json_array_length(wPREGUNTAS);
                wCANTIDAD_PREGUNTAS_TOTAL := 0;

                -- INSERTAR LAS PREGUNTAS DE FORMA RANDOM
                FOR i IN 0..wNUMERO_PREGUNTAS-1 LOOP
                    -- OBTENER EL ID DE LA PREGUNTA
                    wID_PREGUNTA_JSON := (wPREGUNTAS->>i)::INTEGER;
                    wID_PREGUNTA_ARRAY := array_append(wID_PREGUNTA_ARRAY, wID_PREGUNTA_JSON);
                    wCANTIDAD_PREGUNTAS_TOTAL := wCANTIDAD_PREGUNTAS_TOTAL + 1;
                END LOOP;
                -- INSERTAR LAS PREGUNTAS DE FORMA RANDOM
                wCANTIDAD_PREGUNTAS_INSERTADAS := 0;

                WHILE wCANTIDAD_PREGUNTAS_INSERTADAS < wCANTIDAD_PREGUNTAS_TOTAL LOOP
                    -- OBTENER UNA PREGUNTA RANDOM QUE AÚN NO HAYA SIDO INSERTADA
                    SELECT INTO wID_PREGUNTA_RANDOM P.ID_PREGUNTA
                    FROM TAB_PREGUNTA P
                    WHERE P.ID_PREGUNTA = ANY(wID_PREGUNTA_ARRAY)
                    AND P.ID_PREGUNTA NOT IN (SELECT ID_PREGUNTA FROM TAB_PRUEBA_PREGUNTAS WHERE ID_PRUEBA = ULTIMOID)
                    ORDER BY RANDOM() LIMIT 1;

                    -- INSERTAR LA PREGUNTA EN LA PRUEBA
                    INSERT INTO TAB_PRUEBA_PREGUNTAS(ID_PRUEBA, ID_PREGUNTA) 
                    VALUES(ULTIMOID, wID_PREGUNTA_RANDOM);
                    wCANTIDAD_PREGUNTAS_INSERTADAS := wCANTIDAD_PREGUNTAS_INSERTADAS + 1;
                END LOOP;

                --ACTUALIZAR EL NUMERO DE PREGUNTAS DE LA PRUEBA
                UPDATE TAB_PRUEBA SET NUMERO_PREGUNTAS = wCANTIDAD_PREGUNTAS_TOTAL WHERE ID_PRUEBA = ULTIMOID;

                -- RETORNAR EL RESULTADO EXITOSO
                RETORNO := json_build_object('CODIGO', 200, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 200), 'DATOS', json_build_object('ID_PRUEBA', ULTIMOID));
                RETURN RETORNO;
            ELSE
                RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 1));
                RETURN RETORNO;
            END IF;
        EXCEPTION
            WHEN OTHERS THEN
                -- ELIMINAR LA PRUEBA SI OCURRE UN ERROR
                DELETE FROM TAB_PRUEBA WHERE ID_PRUEBA = ULTIMOID;
                RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'Error al insertar la prueba');
                RETURN RETORNO;
        END;
    END IF;
END;
$$
LANGUAGE plpgsql;


























--FUNCION PARA INSERTAR UNA PRUEBA Y QUE RETORNE UN JSON CON EL RESULTADO, MENSAJE Y ID DE LA PRUEBA
CREATE OR REPLACE FUNCTION FUN_INSERTAR_PRUEBA_JSON(wNOM_PRUEBA TAB_PRUEBA.NOM_PRUEBA%TYPE,
                            wDESCRIPCION_PRUEBA TAB_PRUEBA.DESCRIPCION_PRUEBA%TYPE) RETURNS JSON AS
$$
    DECLARE
        RETORNO JSON;
        wVALIDAR INTEGER;
        ULTIMOID INTEGER;
    BEGIN
        --VALIDACION DE LOS DATOS A INSERTAR
        wVALIDAR := FUN_VALIDAR_DATOS_PRUEBA(wNOM_PRUEBA, wDESCRIPCION_PRUEBA);
        IF wVALIDAR <> 200 THEN
            RETORNO := json_build_object('CODIGO',wVALIDAR,'MENSAJE',(SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = wVALIDAR));
            RETURN RETORNO;
        ELSE
            --INSERCION DE LOS DATOS
            --OBTENER EL ULTIMO ID DE LA TABLA PRUEBA
            SELECT INTO ULTIMOID funcion_Retorna_ultmoid('TAB_PRUEBA','ID_PRUEBA');
            INSERT INTO TAB_PRUEBA(ID_PRUEBA, NOM_PRUEBA, DESCRIPCION_PRUEBA)
            VALUES(ULTIMOID, wNOM_PRUEBA, wDESCRIPCION_PRUEBA);
            --VERIFICAR SI SE REALIZO LA INSERCION
            IF FOUND THEN
                RETORNO := json_build_object('CODIGO',200,'MENSAJE',(SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 200),'DATOS',json_build_object('ID_PRUEBA',ULTIMOID));
                RETURN RETORNO;
            ELSE
                RETORNO := json_build_object('CODIGO', 1,'MENSAJE',(SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 1)); 
                RETURN RETORNO;
            END IF;
        END IF;
    END;
$$
LANGUAGE plpgsql;
-- FUNCIÓN PARA INSERTAR UNA PRUEBA Y QUE RETORNE UN JSON CON EL RESULTADO, MENSAJE Y ID DE LA PRUEBA TAMBIÉN VINCULAR PREGUNTAS A LA PRUEBA DE FORMA RANDOM Y AUTOMÁTICA TENIENDO EN CUENTA LAS DIFERENTES ÁREAS A EVALUAR
CREATE OR REPLACE FUNCTION FUN_INSERTAR_PRUEBA_RANDOM_JSON(
    wNOM_PRUEBA TAB_PRUEBA.NOM_PRUEBA%TYPE,
    wDESCRIPCION_PRUEBA TAB_PRUEBA.DESCRIPCION_PRUEBA%TYPE,
    wID_AREA_EVALUAR TAB_AREAS_EVALUAR.ID_AREA_EVALUAR%TYPE,
    wCANTIDAD_PREGUNTAS INTEGER) RETURNS JSON AS
$$
    DECLARE
        RETORNO JSON;
        wVALIDAR INTEGER;
        ULTIMOID INTEGER;
        wID_PREGUNTA_RANDOM INTEGER;
        wCANTIDAD_PREGUNTAS_INSERTADAS INTEGER;
        wCANTIDAD_PREGUNTAS_TOTAL_AREA INTEGER;
    BEGIN
        -- VALIDACIÓN DE LOS DATOS A INSERTAR
        wVALIDAR := FUN_VALIDAR_DATOS_PRUEBA(wNOM_PRUEBA, wDESCRIPCION_PRUEBA);
        IF wVALIDAR <> 200 THEN
            RETORNO := json_build_object('CODIGO', wVALIDAR, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = wVALIDAR));
            RETURN RETORNO;
        ELSE
            -- OBTENER EL ÚLTIMO ID DE LA TABLA PRUEBA
            SELECT INTO ULTIMOID funcion_Retorna_ultmoid('TAB_PRUEBA', 'ID_PRUEBA');

            -- INSERCIÓN DE LOS DATOS EN TAB_PRUEBA
            INSERT INTO TAB_PRUEBA(ID_PRUEBA, NOM_PRUEBA, DESCRIPCION_PRUEBA)
            VALUES(ULTIMOID, wNOM_PRUEBA, wDESCRIPCION_PRUEBA);

            -- VERIFICAR SI SE REALIZÓ LA INSERCIÓN
            IF FOUND THEN
                -- OBTENER LA CANTIDAD DE PREGUNTAS EN EL ÁREA A EVALUAR A TRAVÉS DE LOS TEMAS
                SELECT INTO wCANTIDAD_PREGUNTAS_TOTAL_AREA COUNT(*)
                FROM TAB_PREGUNTA P
                JOIN TAB_PREGUNTA_TEMAS PT ON P.ID_PREGUNTA = PT.ID_PREGUNTA
                JOIN TAB_TEMAS_AREAS TA ON PT.ID_TEMA_AREA = TA.ID_TEMA_AREA
                WHERE TA.ID_AREA_EVALUAR = wID_AREA_EVALUAR;

                -- VERIFICAR QUE HAY SUFICIENTES PREGUNTAS DISPONIBLES
                IF wCANTIDAD_PREGUNTAS > wCANTIDAD_PREGUNTAS_TOTAL_AREA THEN
                    RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'No hay suficientes preguntas disponibles en el área evaluada');
                    RETURN RETORNO;
                END IF;

                -- INSERTAR LAS PREGUNTAS DE FORMA RANDOM
                wCANTIDAD_PREGUNTAS_INSERTADAS := 0;

                WHILE wCANTIDAD_PREGUNTAS_INSERTADAS < wCANTIDAD_PREGUNTAS LOOP
                    -- OBTENER UNA PREGUNTA RANDOM QUE AÚN NO HAYA SIDO INSERTADA
                    SELECT INTO wID_PREGUNTA_RANDOM P.ID_PREGUNTA
                    FROM TAB_PREGUNTA P
                    JOIN TAB_PREGUNTA_TEMAS PT ON P.ID_PREGUNTA = PT.ID_PREGUNTA
                    JOIN TAB_TEMAS_AREAS TA ON PT.ID_TEMA_AREA = TA.ID_TEMA_AREA
                    WHERE TA.ID_AREA_EVALUAR = wID_AREA_EVALUAR
                    AND P.ID_PREGUNTA NOT IN (SELECT ID_PREGUNTA FROM TAB_PRUEBA_PREGUNTAS WHERE ID_PRUEBA = ULTIMOID)
                    ORDER BY RANDOM() LIMIT 1;

                    -- INSERTAR LA PREGUNTA EN LA PRUEBA
                    INSERT INTO TAB_PRUEBA_PREGUNTAS(ID_PRUEBA, ID_PREGUNTA) 
                    VALUES(ULTIMOID, wID_PREGUNTA_RANDOM);
                    wCANTIDAD_PREGUNTAS_INSERTADAS := wCANTIDAD_PREGUNTAS_INSERTADAS + 1;
                END LOOP;

                -- RETORNAR EL RESULTADO EXITOSO
                RETORNO := json_build_object('CODIGO', 200, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 200), 'DATOS', json_build_object('ID_PRUEBA', ULTIMOID));
                RETURN RETORNO;
            ELSE
                -- RETORNAR ERROR DE INSERCIÓN
                RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 1));
                RETURN RETORNO;
            END IF;
        END IF;
    END;
$$
LANGUAGE plpgsql;


-- FUNCIÓN PARA INSERTAR UNA PRUEBA Y QUE RETORNE UN JSON CON EL RESULTADO, MENSAJE Y ID DE LA PRUEBA TAMBIÉN VINCULAR PREGUNTAS A LA PRUEBA DE FORMA RANDOM Y AUTOMÁTICA TENIENDO EN CUENTA LOS DIFERENTES TEMAS A EVALUAR
CREATE OR REPLACE FUNCTION FUN_INSERTAR_PRUEBA_RANDOM_JSON1(
    wNOM_PRUEBA TAB_PRUEBA.NOM_PRUEBA%TYPE,
    wDESCRIPCION_PRUEBA TAB_PRUEBA.DESCRIPCION_PRUEBA%TYPE,
    wID_TEMA_AREA TAB_TEMAS_AREAS.ID_TEMA_AREA%TYPE,
    wCANTIDAD_PREGUNTAS INTEGER
) RETURNS JSON AS
$$
    DECLARE
        RETORNO JSON;
        wVALIDAR INTEGER;
        ULTIMOID INTEGER;
        wID_PREGUNTA_RANDOM INTEGER;
        wCANTIDAD_PREGUNTAS_INSERTADAS INTEGER;
        wCANTIDAD_PREGUNTAS_TOTAL_TEMA INTEGER;
    BEGIN
        -- VALIDACIÓN DE LOS DATOS A INSERTAR
        wVALIDAR := FUN_VALIDAR_DATOS_PRUEBA(wNOM_PRUEBA, wDESCRIPCION_PRUEBA);
        IF wVALIDAR <> 200 THEN
            RETORNO := json_build_object('CODIGO', wVALIDAR, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = wVALIDAR));
            RETURN RETORNO;
        ELSE
            -- OBTENER EL ÚLTIMO ID DE LA TABLA PRUEBA
            SELECT INTO ULTIMOID funcion_Retorna_ultmoid('TAB_PRUEBA', 'ID_PRUEBA');

            -- INSERCIÓN DE LOS DATOS EN TAB_PRUEBA
            INSERT INTO TAB_PRUEBA(ID_PRUEBA, NOM_PRUEBA, DESCRIPCION_PRUEBA)
            VALUES(ULTIMOID, wNOM_PRUEBA, wDESCRIPCION_PRUEBA);

            -- VERIFICAR SI SE REALIZÓ LA INSERCIÓN
            IF FOUND THEN
                -- OBTENER LA CANTIDAD DE PREGUNTAS EN EL TEMA A EVALUAR
                SELECT INTO wCANTIDAD_PREGUNTAS_TOTAL_TEMA COUNT(*)
                FROM TAB_PREGUNTA P
                JOIN TAB_PREGUNTA_TEMAS PT ON P.ID_PREGUNTA = PT.ID_PREGUNTA
                WHERE PT.ID_TEMA_AREA = wID_TEMA_AREA;

                -- VERIFICAR QUE HAY SUFICIENTES PREGUNTAS DISPONIBLES
                IF wCANTIDAD_PREGUNTAS > wCANTIDAD_PREGUNTAS_TOTAL_TEMA THEN
                    RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'No hay suficientes preguntas disponibles en el tema evaluado');
                    RETURN RETORNO;
                END IF;

                -- INSERTAR LAS PREGUNTAS DE FORMA RANDOM
                wCANTIDAD_PREGUNTAS_INSERTADAS := 0;

                WHILE wCANTIDAD_PREGUNTAS_INSERTADAS < wCANTIDAD_PREGUNTAS LOOP
                    -- OBTENER UNA PREGUNTA RANDOM QUE AÚN NO HAYA SIDO INSERTADA
                    SELECT INTO wID_PREGUNTA_RANDOM P.ID_PREGUNTA
                    FROM TAB_PREGUNTA P
                    JOIN TAB_PREGUNTA_TEMAS PT ON P.ID_PREGUNTA = PT.ID_PREGUNTA
                    WHERE PT.ID_TEMA_AREA = wID_TEMA_AREA
                    AND P.ID_PREGUNTA NOT IN (SELECT ID_PREGUNTA FROM TAB_PRUEBA_PREGUNTAS WHERE ID_PRUEBA = ULTIMOID)
                    ORDER BY RANDOM() LIMIT 1;

                    -- INSERTAR LA PREGUNTA EN LA PRUEBA
                    INSERT INTO TAB_PRUEBA_PREGUNTAS(ID_PRUEBA, ID_PREGUNTA) 
                    VALUES(ULTIMOID, wID_PREGUNTA_RANDOM);
                    wCANTIDAD_PREGUNTAS_INSERTADAS := wCANTIDAD_PREGUNTAS_INSERTADAS + 1;
                END LOOP;

                -- RETORNAR EL RESULTADO EXITOSO
                RETORNO := json_build_object('CODIGO', 200, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 200), 'DATOS', json_build_object('ID_PRUEBA', ULTIMOID));
                RETURN RETORNO;
            ELSE
                -- RETORNAR ERROR DE INSERCIÓN
                RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 1));
                RETURN RETORNO;
            END IF;
        END IF;
    END;
$$
LANGUAGE plpgsql;





-- FUNCIÓN PARA VINCULAR PREGUNTAS ALEATORIAS A UNA PRUEBA EXISTENTE BASADA EN ÁREAS A EVALUAR
CREATE OR REPLACE FUNCTION FUN_VINCULAR_PREGUNTAS_A_PRUEBA(
    wID_PRUEBA TAB_PRUEBA.ID_PRUEBA%TYPE,
    wID_AREA_EVALUAR TAB_AREAS_EVALUAR.ID_AREA_EVALUAR%TYPE,
    wCANTIDAD_PREGUNTAS INTEGER
) RETURNS JSON AS
$$
    DECLARE
        RETORNO JSON;
        wVALIDAR INTEGER;
        wID_PREGUNTA_RANDOM INTEGER;
        wCANTIDAD_PREGUNTAS_INSERTADAS INTEGER;
        wCANTIDAD_PREGUNTAS_TOTAL_AREA INTEGER;
    BEGIN
        -- VALIDACIÓN DE QUE LA PRUEBA EXISTE
        PERFORM 1 FROM TAB_PRUEBA WHERE ID_PRUEBA = wID_PRUEBA;
        IF NOT FOUND THEN
            RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'La prueba no existe');
            RETURN RETORNO;
        END IF;

        -- OBTENER LA CANTIDAD DE PREGUNTAS EN EL ÁREA A EVALUAR
        SELECT INTO wCANTIDAD_PREGUNTAS_TOTAL_AREA COUNT(*)
        FROM TAB_PREGUNTA P
        JOIN TAB_PREGUNTA_TEMAS PT ON P.ID_PREGUNTA = PT.ID_PREGUNTA
        JOIN TAB_TEMAS_AREAS TA ON PT.ID_TEMA_AREA = TA.ID_TEMA_AREA
        WHERE TA.ID_AREA_EVALUAR = wID_AREA_EVALUAR;

        -- VERIFICAR QUE HAY SUFICIENTES PREGUNTAS DISPONIBLES
        IF wCANTIDAD_PREGUNTAS > wCANTIDAD_PREGUNTAS_TOTAL_AREA THEN
            RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'No hay suficientes preguntas disponibles en el área evaluada');
            RETURN RETORNO;
        END IF;

        -- VINCULAR LAS PREGUNTAS DE FORMA RANDOM
        wCANTIDAD_PREGUNTAS_INSERTADAS := 0;

        WHILE wCANTIDAD_PREGUNTAS_INSERTADAS < wCANTIDAD_PREGUNTAS LOOP
            -- OBTENER UNA PREGUNTA RANDOM QUE AÚN NO HAYA SIDO VINCULADA A LA PRUEBA
            SELECT INTO wID_PREGUNTA_RANDOM P.ID_PREGUNTA
            FROM TAB_PREGUNTA P
            JOIN TAB_PREGUNTA_TEMAS PT ON P.ID_PREGUNTA = PT.ID_PREGUNTA
            JOIN TAB_TEMAS_AREAS TA ON PT.ID_TEMA_AREA = TA.ID_TEMA_AREA
            WHERE TA.ID_AREA_EVALUAR = wID_AREA_EVALUAR
            AND P.ID_PREGUNTA NOT IN (SELECT ID_PREGUNTA FROM TAB_PRUEBA_PREGUNTAS WHERE ID_PRUEBA = wID_PRUEBA)
            ORDER BY RANDOM() LIMIT 1;

            -- VINCULAR LA PREGUNTA A LA PRUEBA
            INSERT INTO TAB_PRUEBA_PREGUNTAS(ID_PRUEBA, ID_PREGUNTA) 
            VALUES(wID_PRUEBA, wID_PREGUNTA_RANDOM);
            wCANTIDAD_PREGUNTAS_INSERTADAS := wCANTIDAD_PREGUNTAS_INSERTADAS + 1;
        END LOOP;

        -- RETORNAR EL RESULTADO EXITOSO
        RETORNO := json_build_object('CODIGO', 200, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 200), 'DATOS', json_build_object('ID_PRUEBA', wID_PRUEBA));
        RETURN RETORNO;
    END;
$$
LANGUAGE plpgsql;



-- FUNCIÓN PARA VINCULAR PREGUNTAS ALEATORIAS A UNA PRUEBA EXISTENTE BASADA EN TEMAS A EVALUAR
CREATE OR REPLACE FUNCTION FUN_VINCULAR_PREGUNTAS_A_PRUEBA_POR_TEMA(
    wID_PRUEBA TAB_PRUEBA.ID_PRUEBA%TYPE,
    wID_TEMA_AREA TAB_TEMAS_AREAS.ID_TEMA_AREA%TYPE,
    wCANTIDAD_PREGUNTAS INTEGER
) RETURNS JSON AS
$$
    DECLARE
        RETORNO JSON;
        wVALIDAR INTEGER;
        wID_PREGUNTA_RANDOM INTEGER;
        wCANTIDAD_PREGUNTAS_INSERTADAS INTEGER;
        wCANTIDAD_PREGUNTAS_TOTAL_TEMA INTEGER;
    BEGIN
        -- VALIDACIÓN DE QUE LA PRUEBA EXISTE
        PERFORM 1 FROM TAB_PRUEBA WHERE ID_PRUEBA = wID_PRUEBA;
        IF NOT FOUND THEN
            RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'La prueba no existe');
            RETURN RETORNO;
        END IF;

        -- OBTENER LA CANTIDAD DE PREGUNTAS EN EL TEMA A EVALUAR
        SELECT INTO wCANTIDAD_PREGUNTAS_TOTAL_TEMA COUNT(*)
        FROM TAB_PREGUNTA P
        JOIN TAB_PREGUNTA_TEMAS PT ON P.ID_PREGUNTA = PT.ID_PREGUNTA
        WHERE PT.ID_TEMA_AREA = wID_TEMA_AREA;

        -- VERIFICAR QUE HAY SUFICIENTES PREGUNTAS DISPONIBLES
        IF wCANTIDAD_PREGUNTAS > wCANTIDAD_PREGUNTAS_TOTAL_TEMA THEN
            RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'No hay suficientes preguntas disponibles en el tema evaluado');
            RETURN RETORNO;
        END IF;

        -- VINCULAR LAS PREGUNTAS DE FORMA RANDOM
        wCANTIDAD_PREGUNTAS_INSERTADAS := 0;

        WHILE wCANTIDAD_PREGUNTAS_INSERTADAS < wCANTIDAD_PREGUNTAS LOOP
            -- OBTENER UNA PREGUNTA RANDOM QUE AÚN NO HAYA SIDO VINCULADA A LA PRUEBA
            SELECT INTO wID_PREGUNTA_RANDOM P.ID_PREGUNTA
            FROM TAB_PREGUNTA P
            JOIN TAB_PREGUNTA_TEMAS PT ON P.ID_PREGUNTA = PT.ID_PREGUNTA
            WHERE PT.ID_TEMA_AREA = wID_TEMA_AREA
            AND P.ID_PREGUNTA NOT IN (SELECT ID_PREGUNTA FROM TAB_PRUEBA_PREGUNTAS WHERE ID_PRUEBA = wID_PRUEBA)
            ORDER BY RANDOM() LIMIT 1;

            -- VINCULAR LA PREGUNTA A LA PRUEBA
            INSERT INTO TAB_PRUEBA_PREGUNTAS(ID_PRUEBA, ID_PREGUNTA) 
            VALUES(wID_PRUEBA, wID_PREGUNTA_RANDOM);
            wCANTIDAD_PREGUNTAS_INSERTADAS := wCANTIDAD_PREGUNTAS_INSERTADAS + 1;
        END LOOP;

        -- RETORNAR EL RESULTADO EXITOSO
        RETORNO := json_build_object('CODIGO', 200, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 200), 'DATOS', json_build_object('ID_PRUEBA', wID_PRUEBA));
        RETURN RETORNO;
    END;
$$
LANGUAGE plpgsql;



--FUNCION PARA OBTENER TODAS LAS PRUEBAS DE LA BASE DE DATOS Y RETORNAR UN JSON CON EL RESULTADO
CREATE OR REPLACE FUNCTION FUN_OBTENER_PRUEBAS_JSON() RETURNS JSON AS
$$
    DECLARE
        RETORNO JSON;
        DATOS JSON;
    BEGIN
        --OBTENER TODAS LAS PRUEBAS DE LA BASE DE DATOS
        DATOS := (SELECT json_agg(json_build_object('ID_PRUEBA', ID_PRUEBA, 'NOM_PRUEBA', NOM_PRUEBA, 'DESCRIPCION_PRUEBA', DESCRIPCION_PRUEBA, 'TIPO_PRUEBA', TIPO_PRUEBA, 'FECHA_PRUEBA_INICIO', FECHA_PRUEBA_INICIO, 'FECHA_PRUEBA_FIN', FECHA_PRUEBA_FIN, 'DURACION_PRUEBA_MINUTOS', DURACION_PRUEBA_MINUTOS, 'NUMERO_PREGUNTAS', NUMERO_PREGUNTAS))
        FROM TAB_PRUEBA);
        --VALIDAR SI SE OBTUVIERON DATOS
        IF DATOS IS NULL THEN
            RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'No se encontraron pruebas en la base de datos');
            RETURN RETORNO;
        ELSE
            RETORNO := json_build_object('CODIGO', 200, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 200), 'DATOS', DATOS);
			RETURN RETORNO;
        END IF;

    END;
$$
LANGUAGE plpgsql;

--FUNCION PARA OBTENER UNA PRUEBA DE LA BASE DE DATOS Y RETORNAR UN JSON CON EL RESULTADO
CREATE OR REPLACE FUNCTION FUN_OBTENER_PRUEBA_JSON(wID_PRUEBA TAB_PRUEBA.ID_PRUEBA%TYPE) RETURNS JSON AS
$$
    DECLARE
        RETORNO JSON;
        DATOS JSON;
    BEGIN
        --OBTENER LA PRUEBA DE LA BASE DE DATOS
        DATOS := (SELECT json_build_object('ID_PRUEBA', ID_PRUEBA, 'NOM_PRUEBA', NOM_PRUEBA, 'DESCRIPCION_PRUEBA', DESCRIPCION_PRUEBA, 'TIPO_PRUEBA', TIPO_PRUEBA, 'FECHA_PRUEBA_INICIO', FECHA_PRUEBA_INICIO, 'FECHA_PRUEBA_FIN', FECHA_PRUEBA_FIN, 'DURACION_PRUEBA_MINUTOS', DURACION_PRUEBA_MINUTOS, 'NUMERO_PREGUNTAS', NUMERO_PREGUNTAS)
        FROM TAB_PRUEBA WHERE ID_PRUEBA = wID_PRUEBA);
        --VALIDAR SI SE OBTUVIERON DATOS
        IF DATOS IS NULL THEN
            RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'No se encontró la prueba en la base de datos');
            RETURN RETORNO;
        ELSE
            RETORNO := json_build_object('CODIGO', 200, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 200), 'DATOS', DATOS);
            RETURN RETORNO;
        END IF;
    END;
$$
LANGUAGE plpgsql;






--FUNCION PARA VINCULAR LOS ESTUDIANTES DE UN GRUPO DE ESTUDIO A UNA PRUEBA USANDO LA TABLA TAB_PRUEBA_ESTUDIANTE Y RETORNAR UN JSON CON EL RESULTADO
CREATE OR REPLACE FUNCTION FUN_VINCULAR_ESTUDIANTES_A_PRUEBA(
    wID_PRUEBA TAB_PRUEBA.ID_PRUEBA%TYPE,
    wID_GRUPO_ESTUDIO TAB_GRUPO_ESTUDIO.ID_GRUPO_ESTUDIO%TYPE
) RETURNS JSON AS
$$
    DECLARE
        RETORNO JSON;
        wVALIDAR INTEGER;
        wID_ESTUDIANTE VARCHAR;
        wCANTIDAD_ESTUDIANTES_INSERTADOS INTEGER;
    BEGIN
        -- VALIDACIÓN DE QUE LA PRUEBA EXISTE
        PERFORM 1 FROM TAB_PRUEBA WHERE ID_PRUEBA = wID_PRUEBA;
        IF NOT FOUND THEN
            RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'La prueba no existe');
            RETURN RETORNO;
        END IF;

        -- VALIDACIÓN DE QUE EL GRUPO DE ESTUDIO EXISTE
        PERFORM 1 FROM TAB_GRUPO_ESTUDIO WHERE ID_GRUPO_ESTUDIO = wID_GRUPO_ESTUDIO;
        IF NOT FOUND THEN
            RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'El grupo de estudio no existe');
            RETURN RETORNO;
        END IF;

        -- VINCULAR LOS ESTUDIANTES DEL GRUPO DE ESTUDIO A LA PRUEBA
        wCANTIDAD_ESTUDIANTES_INSERTADOS := 0;

        FOR wID_ESTUDIANTE IN (SELECT ID_ESTUDIANTE FROM TAB_ESTUDIANTE WHERE ID_GRUPO_ESTUDIO = wID_GRUPO_ESTUDIO) LOOP
            -- VERIFICAR QUE EL ESTUDIANTE NO ESTÉ YA VINCULADO A LA PRUEBA
            PERFORM 1 FROM TAB_PRUEBA_ESTUDIANTE WHERE ID_PRUEBA = wID_PRUEBA AND ID_ESTUDIANTE = wID_ESTUDIANTE;
            IF NOT FOUND THEN
                -- VINCULAR EL ESTUDIANTE A LA PRUEBA
                INSERT INTO TAB_PRUEBA_ESTUDIANTE(ID_PRUEBA, ID_ESTUDIANTE) 
                VALUES(wID_PRUEBA, wID_ESTUDIANTE);
                wCANTIDAD_ESTUDIANTES_INSERTADOS := wCANTIDAD_ESTUDIANTES_INSERTADOS + 1;
            END IF;
        END LOOP;

        -- RETORNAR EL RESULTADO EXITOSO
        RETORNO := json_build_object('CODIGO', 200, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 200), 'DATOS', json_build_object('ID_PRUEBA', wID_PRUEBA, 'CANTIDAD_ESTUDIANTES_INSERTADOS', wCANTIDAD_ESTUDIANTES_INSERTADOS));
        RETURN RETORNO;
    END;
$$
LANGUAGE plpgsql;


--FUNCION PARA VINCULAR LOS ESTUDIANTES USANDO EL ID_ESTUDIANTE A UNA PRUEBA USANDO LA TABLA TAB_PRUEBA_ESTUDIANTE Y RETORNAR UN JSON CON EL RESULTADO
CREATE OR REPLACE FUNCTION FUN_VINCULAR_ESTUDIANTE_A_PRUEBA(
    wID_PRUEBA TAB_PRUEBA.ID_PRUEBA%TYPE,
    wID_ESTUDIANTE TAB_ESTUDIANTE.ID_ESTUDIANTE%TYPE
) RETURNS JSON AS
$$
    DECLARE
        RETORNO JSON;
        wVALIDAR INTEGER;
        wCANTIDAD_ESTUDIANTES_INSERTADOS INTEGER;
    BEGIN
        -- VALIDACIÓN DE QUE LA PRUEBA EXISTE
        PERFORM 1 FROM TAB_PRUEBA WHERE ID_PRUEBA = wID_PRUEBA;
        IF NOT FOUND THEN
            RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'La prueba no existe');
            RETURN RETORNO;
        END IF;

        -- VALIDACIÓN DE QUE EL ESTUDIANTE EXISTE
        PERFORM 1 FROM TAB_ESTUDIANTE WHERE ID_ESTUDIANTE = wID_ESTUDIANTE;
        IF NOT FOUND THEN
            RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'El estudiante no existe');
            RETURN RETORNO;
        END IF;

        -- VERIFICAR QUE EL ESTUDIANTE NO ESTÉ YA VINCULADO A LA PRUEBA
        PERFORM 1 FROM TAB_PRUEBA_ESTUDIANTE WHERE ID_PRUEBA = wID_PRUEBA AND ID_ESTUDIANTE = wID_ESTUDIANTE;
        IF NOT FOUND THEN
            -- VINCULAR EL ESTUDIANTE A LA PRUEBA
            INSERT INTO TAB_PRUEBA_ESTUDIANTE(ID_PRUEBA, ID_ESTUDIANTE) 
            VALUES(wID_PRUEBA, wID_ESTUDIANTE);
            wCANTIDAD_ESTUDIANTES_INSERTADOS := 1;
        ELSE
            wCANTIDAD_ESTUDIANTES_INSERTADOS := 0;
        END IF;

        -- RETORNAR EL RESULTADO EXITOSO
        RETORNO := json_build_object('CODIGO', 200, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 200), 'DATOS', json_build_object('ID_PRUEBA', wID_PRUEBA, 'CANTIDAD_ESTUDIANTES_INSERTADOS', wCANTIDAD_ESTUDIANTES_INSERTADOS));
        RETURN RETORNO;
    END;
$$
LANGUAGE plpgsql;


-- FUNCION PARA OBTENER LOS DATOS DE LA PRUEBA, ES DECIR TODOS SUS CONTEXTOS, PREGUNTAS Y OPCIONES TENIENDO EN CUENTA EL ID DE LA PRUEBA Y RETORNAR UN JSON CON EL RESULTADO TAMBIEN ORDENARLOS YA QUE VARIAS PREGUNTAS PUEDEN TENER EL MISMO CONTEXTO
CREATE OR REPLACE FUNCTION FUN_OBTENER_PRUEBA_DATOS_PREVIEW_JSON(wID_PRUEBA TAB_PRUEBA.ID_PRUEBA%TYPE) RETURNS JSON AS
$$
    DECLARE
        PRUEBA JSON;
        RETORNO JSON;
        CONTEXTOS JSON;
        PREGUNTAS JSON;
        OPCIONES JSON;
        DATOS JSON;
    BEGIN
        -- OBTENER LOS DATOS DE LA PRUEBA DE LA BASE DE DATOS
        PRUEBA := (SELECT json_build_object('ID_PRUEBA', ID_PRUEBA, 'NOM_PRUEBA', NOM_PRUEBA, 'DESCRIPCION_PRUEBA', DESCRIPCION_PRUEBA, 'TIPO_PRUEBA', TIPO_PRUEBA, 'FECHA_PRUEBA_INICIO', FECHA_PRUEBA_INICIO, 'FECHA_PRUEBA_FIN', FECHA_PRUEBA_FIN, 'DURACION_PRUEBA_MINUTOS', DURACION_PRUEBA_MINUTOS, 'NUMERO_PREGUNTAS', NUMERO_PREGUNTAS)
        FROM TAB_PRUEBA WHERE ID_PRUEBA = wID_PRUEBA);
        
        -- VALIDAR SI SE OBTUVIERON DATOS
        IF PRUEBA IS NULL THEN
            RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'No se encontró la prueba en la base de datos');
            RETURN RETORNO;
        ELSE
            -- OBTENER LOS CONTEXTOS A TRAVÉS DE LAS PREGUNTAS YA QUE TAB_PRUEBA_PREGUNTAS TIENE LA RELACION DE LAS PREGUNTAS CON LA PRUEBA Y TAB_PREGUNTA TIENE LA RELACION DE LOS CONTEXTOS CON LAS PREGUNTAS EN UNA FK
            CONTEXTOS := (SELECT json_agg(json_build_object('ID_CONTEXTO', subquery.ID_CONTEXTO, 'DESC_CONTEXTO', subquery.DESC_CONTEXTO, 'LINK_MEDIA', subquery.LINK_MEDIA, 'TIPO_CONTEXTO', subquery.TIPO_CONTEXTO))
            FROM (
                SELECT DISTINCT C.ID_CONTEXTO, C.DESC_CONTEXTO, C.LINK_MEDIA, C.TIPO_CONTEXTO
                FROM TAB_CONTEXTO C 
                JOIN TAB_PREGUNTA P ON C.ID_CONTEXTO = P.ID_CONTEXTO
                JOIN TAB_PRUEBA_PREGUNTAS PP ON P.ID_PREGUNTA = PP.ID_PREGUNTA
                WHERE PP.ID_PRUEBA = wID_PRUEBA
            ) AS subquery);
            
            -- OBTENER LAS PREGUNTAS DE LA PRUEBA TENIENDO EN CUENTA QUE EN LA TAB_PRUEBA_PREGUNTAS ESTAN RELACIONADAS LAS PREGUNTAS CON LA PRUEBA
            PREGUNTAS := (SELECT json_agg(json_build_object('ID_PREGUNTA', P.ID_PREGUNTA, 'ID_CONTEXTO', P.ID_CONTEXTO, 'ENUNCIADO_PREGUNTA', P.ENUNCIADO_PREGUNTA, 'TIPO_PREGUNTA', P.TIPO_PREGUNTA, 'IMAGEN_PREGUNTA', P.IMAGEN_PREGUNTA, 'TIPO_PREGUNTA_CONTENIDO', P.TIPO_PREGUNTA_CONTENIDO, 'LAYOUT_PREGUNTA', P.LAYOUT_PREGUNTA))
            FROM TAB_PREGUNTA P 
            JOIN TAB_PRUEBA_PREGUNTAS PP ON P.ID_PREGUNTA = PP.ID_PREGUNTA
            WHERE PP.ID_PRUEBA = wID_PRUEBA);

            -- OBTENER LAS OPCIONES DE LAS PREGUNTAS DE LA PRUEBA TENIENDO EN CUENTA QUE EN LA TAB_OPCIONES_PREGUNTA TIENE LA FK DE LA PREGUNTA
            OPCIONES := (SELECT json_agg(json_build_object('ID_OPCION', OP.ID_OPCION, 'ID_PREGUNTA', OP.ID_PREGUNTA, 'TEXTO_OPCION', OP.TEXTO_OPCION, 'IMAGEN_OPCION', OP.IMAGEN_OPCION, 'TIPO_OPCION', OP.TIPO_OPCION))
            FROM TAB_OPCIONES_PREGUNTA OP 
            JOIN TAB_PREGUNTA P ON OP.ID_PREGUNTA = P.ID_PREGUNTA
            JOIN TAB_PRUEBA_PREGUNTAS PP ON P.ID_PREGUNTA = PP.ID_PREGUNTA
            WHERE PP.ID_PRUEBA = wID_PRUEBA);

            -- CONCATENAR LOS DATOS DE LA PRUEBA, CONTEXTOS, PREGUNTAS Y OPCIONES
            DATOS := json_build_object('PRUEBA', PRUEBA, 'CONTEXTOS', CONTEXTOS, 'PREGUNTAS', PREGUNTAS, 'OPCIONES', OPCIONES);
            RETORNO := json_build_object('CODIGO', 200, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 200), 'DATOS', DATOS);
            RETURN RETORNO;
        END IF;
    END;
$$
LANGUAGE plpgsql;


--FUNCION QUE ME RETORNA EN UN JSON TODOS LOS ID DE LAS PREGUNTAS DE UNA PRUEBA
CREATE OR REPLACE FUNCTION FUN_OBTENER_ID_PREGUNTAS_PRUEBA_JSON(wID_PRUEBA TAB_PRUEBA.ID_PRUEBA%TYPE) RETURNS JSON AS
$$
    DECLARE
        RETORNO JSON;
        DATOS JSON;
    BEGIN
        --OBTENER TODOS LOS ID DE LAS PREGUNTAS DE UNA PRUEBA
        DATOS := (SELECT json_agg(json_build_object('ID_PREGUNTA', ID_PREGUNTA))
        FROM TAB_PRUEBA_PREGUNTAS WHERE ID_PRUEBA = wID_PRUEBA);
        --VALIDAR SI SE OBTUVIERON DATOS
        IF DATOS IS NULL THEN
            RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'No se encontraron preguntas en la prueba');
            RETURN RETORNO;
        ELSE
            RETORNO := json_build_object('CODIGO', 200, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 200), 'DATOS', DATOS);
            RETURN RETORNO;
        END IF;
    END;
$$
LANGUAGE plpgsql;

--FUNCION QUE ME PERMITE OBTENER LAS PRUEBAS ACTIVAS DE UN ESTUDIANTE USANDO EL ID_ESTUDIANTE Y RETORNAR UN JSON CON EL RESULTADO
CREATE OR REPLACE FUNCTION FUN_OBTENER_PRUEBAS_ACTIVAS_ESTUDIANTE_JSON(wID_ESTUDIANTE TAB_ESTUDIANTE.ID_ESTUDIANTE%TYPE) RETURNS JSON AS
$$
    DECLARE
        RETORNO JSON;
        DATOS JSON;
    BEGIN
        --OBTENER LAS PRUEBAS ACTIVAS DE UN ESTUDIANTE
        DATOS := (SELECT json_agg(json_build_object('ID_PRUEBA', P.ID_PRUEBA, 'NOM_PRUEBA', P.NOM_PRUEBA, 'DESCRIPCION_PRUEBA', P.DESCRIPCION_PRUEBA, 'TIPO_PRUEBA', P.TIPO_PRUEBA, 'FECHA_PRUEBA_INICIO', P.FECHA_PRUEBA_INICIO, 'FECHA_PRUEBA_FIN', P.FECHA_PRUEBA_FIN, 'DURACION_PRUEBA_MINUTOS', P.DURACION_PRUEBA_MINUTOS, 'NUMERO_PREGUNTAS', P.NUMERO_PREGUNTAS))
        FROM TAB_PRUEBA P
        JOIN TAB_PRUEBA_ESTUDIANTE PE ON P.ID_PRUEBA = PE.ID_PRUEBA
        WHERE PE.ID_ESTUDIANTE = wID_ESTUDIANTE AND PE.FECHA_PRUEBA_INICIO_ESTUDIANTE IS NULL AND PE.FECHA_PRUEBA_FIN_ESTUDIANTE IS NULL AND P.FECHA_PRUEBA_INICIO <= NOW() AND P.FECHA_PRUEBA_FIN >= NOW() AND P.PRUEBA_ACTIVA = TRUE);
        --VALIDAR SI SE OBTUVIERON DATOS
        IF DATOS IS NULL THEN
            RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'No se encontraron pruebas activas para el estudiante');
            RETURN RETORNO;
        ELSE
            RETORNO := json_build_object('CODIGO', 200, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 200), 'DATOS', DATOS);
            RETURN RETORNO;
        END IF;
    END;
$$
LANGUAGE plpgsql;

--FUNCION QUE ME PERMITE OBTENER LAS PRUEBAS EN CURSO DE UN ESTUDIANTE USANDO EL ID_ESTUDIANTE Y RETORNAR UN JSON CON EL RESULTADO
CREATE OR REPLACE FUNCTION FUN_OBTENER_PRUEBAS_EN_CURSO_ESTUDIANTE_JSON(wID_ESTUDIANTE TAB_ESTUDIANTE.ID_ESTUDIANTE%TYPE) RETURNS JSON AS
$$
    DECLARE
        RETORNO JSON;
        DATOS JSON;
    BEGIN
        --OBTENER LAS PRUEBAS ACTIVAS DE UN ESTUDIANTE
        DATOS := (SELECT json_agg(json_build_object('ID_PRUEBA', P.ID_PRUEBA, 'NOM_PRUEBA', P.NOM_PRUEBA, 'DESCRIPCION_PRUEBA', P.DESCRIPCION_PRUEBA, 'TIPO_PRUEBA', P.TIPO_PRUEBA, 'FECHA_PRUEBA_INICIO', P.FECHA_PRUEBA_INICIO, 'FECHA_PRUEBA_FIN', P.FECHA_PRUEBA_FIN, 'DURACION_PRUEBA_MINUTOS', P.DURACION_PRUEBA_MINUTOS, 'NUMERO_PREGUNTAS', P.NUMERO_PREGUNTAS))
        FROM TAB_PRUEBA P
        JOIN TAB_PRUEBA_ESTUDIANTE PE ON P.ID_PRUEBA = PE.ID_PRUEBA
        WHERE PE.ID_ESTUDIANTE = wID_ESTUDIANTE AND PE.FECHA_PRUEBA_INICIO_ESTUDIANTE IS NOT NULL AND PE.FECHA_PRUEBA_FIN_ESTUDIANTE IS NULL AND P.FECHA_PRUEBA_INICIO <= NOW() AND P.FECHA_PRUEBA_FIN >= NOW() AND P.PRUEBA_ACTIVA = TRUE);
        --VALIDAR SI SE OBTUVIERON DATOS
        IF DATOS IS NULL THEN
            RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'No se encontraron pruebas activas para el estudiante');
            RETURN RETORNO;
        ELSE
            RETORNO := json_build_object('CODIGO', 200, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 200), 'DATOS', DATOS);
            RETURN RETORNO;
        END IF;
    END;
$$
LANGUAGE plpgsql;

--FUNCION QUE ME PERMITE OBTENER LAS PRUEBAS EN CURSO DE UN ESTUDIANTE USANDO EL ID_ESTUDIANTE Y RETORNAR UN JSON CON EL RESULTADO
CREATE OR REPLACE FUNCTION FUN_OBTENER_FINALIZADAS_ESTUDIANTE_JSON(wID_ESTUDIANTE TAB_ESTUDIANTE.ID_ESTUDIANTE%TYPE) RETURNS JSON AS
$$
    DECLARE
        RETORNO JSON;
        DATOS JSON;
    BEGIN
        --OBTENER LAS PRUEBAS ACTIVAS DE UN ESTUDIANTE
        DATOS := (SELECT json_agg(json_build_object('ID_PRUEBA', P.ID_PRUEBA, 'NOM_PRUEBA', P.NOM_PRUEBA, 'DESCRIPCION_PRUEBA', P.DESCRIPCION_PRUEBA, 'TIPO_PRUEBA', P.TIPO_PRUEBA, 'FECHA_PRUEBA_INICIO', P.FECHA_PRUEBA_INICIO, 'FECHA_PRUEBA_FIN', P.FECHA_PRUEBA_FIN, 'DURACION_PRUEBA_MINUTOS', P.DURACION_PRUEBA_MINUTOS, 'NUMERO_PREGUNTAS', P.NUMERO_PREGUNTAS))
        FROM TAB_PRUEBA P
        JOIN TAB_PRUEBA_ESTUDIANTE PE ON P.ID_PRUEBA = PE.ID_PRUEBA
        WHERE PE.ID_ESTUDIANTE = wID_ESTUDIANTE AND PE.FECHA_PRUEBA_INICIO_ESTUDIANTE IS NOT NULL AND PE.FECHA_PRUEBA_FIN_ESTUDIANTE IS NOT NULL AND P.FECHA_PRUEBA_INICIO <= NOW() );
        --VALIDAR SI SE OBTUVIERON DATOS
        IF DATOS IS NULL THEN
            RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'No se encontraron pruebas activas para el estudiante');
            RETURN RETORNO;
        ELSE
            RETORNO := json_build_object('CODIGO', 200, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 200), 'DATOS', DATOS);
            RETURN RETORNO;
        END IF;
    END;
$$
LANGUAGE plpgsql;









--FUNCION QUE ME PERMITE REGISTRAR LA FECHA FIN DE LA PRUEBA PRESENTADA POR EL ESTUDIANTE USANDO EL ID_ESTUDIANTE ,EL ID_PRUEBA Y CON_ID Y RETORNAR UN JSON CON EL RESULTADO
CREATE OR REPLACE FUNCTION FUN_REGISTRAR_FECHA_FIN_PRUEBA_ESTUDIANTE(wID_PRUEBA TAB_PRUEBA.ID_PRUEBA%TYPE,
    wID_ESTUDIANTE TAB_ESTUDIANTE.ID_ESTUDIANTE%TYPE)
RETURNS JSON AS 
$$
DECLARE
    RETORNO JSON;
BEGIN
	SET TIME ZONE 'America/Bogota';
    -- Tu lógica para registrar la fecha de fin de la prueba
    UPDATE TAB_PRUEBA_ESTUDIANTE SET FECHA_PRUEBA_FIN_ESTUDIANTE = NOW() WHERE ID_PRUEBA = wID_PRUEBA AND ID_ESTUDIANTE = wID_ESTUDIANTE AND FECHA_PRUEBA_FIN_ESTUDIANTE IS NULL;
    --VALIDAR SI SE REGISTRO LA FECHA DE FIN DE LA PRUEBA
    IF FOUND THEN
        --RETORNAR EL RESULTADO EXITOSO
        RETORNO := json_build_object('CODIGO', 200, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 200));
        RETURN RETORNO;
    ELSE
        --RETORNAR EL RESULTADO FALLIDO
        RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'No se pudo registrar la fecha de fin de la prueba para el estudiante');
        RETURN RETORNO;
    END IF;
END;
$$ 
LANGUAGE plpgsql;


--FUNCION QUE ME PERMITE REGISTRAR LA FECHA DE INICIO DEL ESTUDIANTE EN UNA PRUEBA USANDO EL ID_ESTUDIANTE Y EL ID_PRUEBA Y RETORNAR UN JSON CON EL RESULTADO
CREATE OR REPLACE FUNCTION FUN_REGISTRAR_FECHA_INICIO_PRUEBA_ESTUDIANTE(
    wID_PRUEBA TAB_PRUEBA.ID_PRUEBA%TYPE,
    wID_ESTUDIANTE TAB_ESTUDIANTE.ID_ESTUDIANTE%TYPE
) RETURNS JSON AS
$$
    DECLARE
        RETORNO JSON;
        wVALIDAR INTEGER;

    BEGIN
        -- VALIDACIÓN DE QUE LA PRUEBA EXISTE
        PERFORM 1 FROM TAB_PRUEBA WHERE ID_PRUEBA = wID_PRUEBA;
        IF NOT FOUND THEN
            RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'La prueba no existe');
            RETURN RETORNO;
        END IF;

        -- VALIDACIÓN DE QUE EL ESTUDIANTE EXISTE
        PERFORM 1 FROM TAB_ESTUDIANTE WHERE ID_ESTUDIANTE = wID_ESTUDIANTE;
        IF NOT FOUND THEN
            RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'El estudiante no existe');
            RETURN RETORNO;
        END IF;
		SET TIME ZONE 'America/Bogota';


        -- REGISTRAR LA FECHA DE INICIO DE LA PRUEBA PARA EL ESTUDIANTE SIEMPRE Y CUANDO NO HAYA REGISTRADO YA LA FECHA DE INICIO
        UPDATE TAB_PRUEBA_ESTUDIANTE SET FECHA_PRUEBA_INICIO_ESTUDIANTE = NOW() WHERE ID_PRUEBA = wID_PRUEBA AND ID_ESTUDIANTE = wID_ESTUDIANTE AND FECHA_PRUEBA_INICIO_ESTUDIANTE IS NULL;

        -- RETORNAR EL RESULTADO EXITOSO SI SE REGISTRÓ LA FECHA DE INICIO
        IF FOUND THEN
            RETORNO := json_build_object('CODIGO', 200, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 200));
            RETURN RETORNO;
        ELSE
            RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'No se pudo registrar la fecha de inicio de la prueba para el estudiante');
            RETURN RETORNO;
        END IF;
    END;
$$
LANGUAGE plpgsql;


--FUNCION QUE ME PERMITE CAPTURAR LA FECHA DE INICIO DE LA PRUEBA DE LA TABLA TAB_PRUEBA_ESTUDIANTE USANDO EL ID_PRUEBA Y EL ID_ESTUDIANTE Y EL TIEMPO DE DURACION DE LA PRUEBA DE LA TABLA TAB_PRUEBA Y RETORNAR UN JSON CON EL RESULTADO
CREATE OR REPLACE FUNCTION FUN_CAPTURAR_FECHA_INICIO_PRUEBA_ESTUDIANTE(
    wID_PRUEBA TAB_PRUEBA.ID_PRUEBA%TYPE,
    wID_ESTUDIANTE TAB_ESTUDIANTE.ID_ESTUDIANTE%TYPE
) RETURNS JSON AS
$$
    DECLARE
        RETORNO JSON;
        wVALIDAR INTEGER;
        wDURACION_PRUEBA_MINUTOS INTEGER;
        wFECHA_INICIO_PRUEBA_ESTUDIANTE TIMESTAMP;
        WFECHA_FIN_PRUEBA_ESTUDIANTE TIMESTAMP;
        DATOS JSON;
    BEGIN
        -- VALIDACIÓN DE QUE LA PRUEBA EXISTE
        PERFORM 1 FROM TAB_PRUEBA WHERE ID_PRUEBA = wID_PRUEBA;
        IF NOT FOUND THEN
            RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'La prueba no existe');
            RETURN RETORNO;
        END IF;

        -- VALIDACIÓN DE QUE EL ESTUDIANTE EXISTE
        PERFORM 1 FROM TAB_ESTUDIANTE WHERE ID_ESTUDIANTE = wID_ESTUDIANTE;
        IF NOT FOUND THEN
            RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'El estudiante no existe');
            RETURN RETORNO;
        END IF;

        -- OBTENER LA DURACIÓN DE LA PRUEBA
        SELECT DURACION_PRUEBA_MINUTOS INTO wDURACION_PRUEBA_MINUTOS 
        FROM TAB_PRUEBA
        WHERE ID_PRUEBA = wID_PRUEBA;

        --OBTENER LA FECHA DE INICIO DE LA PRUEBA PARA EL ESTUDIANTE SIEMPRE Y CUANDO NO HAYA REGISTRADO YA LA FECHA DE INICIO
        SELECT FECHA_PRUEBA_INICIO_ESTUDIANTE INTO wFECHA_INICIO_PRUEBA_ESTUDIANTE  
        FROM TAB_PRUEBA_ESTUDIANTE 
        WHERE ID_PRUEBA = wID_PRUEBA AND ID_ESTUDIANTE = wID_ESTUDIANTE ;

        --OBTENER LA FECHA DE FIN DE LA PRUEBA PARA EL ESTUDIANTE SIEMPRE Y CUANDO NO HAYA REGISTRADO YA LA FECHA DE FIN
        SELECT FECHA_PRUEBA_FIN_ESTUDIANTE INTO WFECHA_FIN_PRUEBA_ESTUDIANTE
        FROM TAB_PRUEBA_ESTUDIANTE 
        WHERE ID_PRUEBA = wID_PRUEBA AND ID_ESTUDIANTE = wID_ESTUDIANTE ;

        --GUARDAR LOS DATOS EN UN JSON
        DATOS := json_build_object('ID_PRUEBA', wID_PRUEBA, 'ID_ESTUDIANTE', wID_ESTUDIANTE, 'FECHA_INICIO_PRUEBA_ESTUDIANTE', wFECHA_INICIO_PRUEBA_ESTUDIANTE, 'FECHA_FIN_PRUEBA_ESTUDIANTE', WFECHA_FIN_PRUEBA_ESTUDIANTE, 'DURACION_PRUEBA_MINUTOS', wDURACION_PRUEBA_MINUTOS);
        
        -- RETORNAR EL RESULTADO EXITOSO SI SE REGISTRÓ LA FECHA DE INICIO
        IF FOUND THEN
            RETORNO := json_build_object('CODIGO', 200, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 200), 'DATOS', DATOS);
            RETURN RETORNO;
        ELSE
            RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'No se pudo capturar la fecha de inicio de la prueba para el estudiante');
            RETURN RETORNO;
        END IF;
    END;
$$
LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION FUN_REGISTRAR_RESPUESTA_PREGUNTA_ESTUDIANTE(
    wID_PRUEBA TAB_PRUEBA.ID_PRUEBA%TYPE,
    wID_ESTUDIANTE TAB_ESTUDIANTE.ID_ESTUDIANTE%TYPE,
    PREGUNTAS_OPCIONES JSON
) RETURNS JSON AS
$$
    DECLARE
        RETORNO JSON;
        wVALIDAR INTEGER;
        wID_PREGUNTA TAB_PREGUNTA.ID_PREGUNTA%TYPE;
        wID_OPCION TAB_OPCIONES_PREGUNTA.ID_OPCION%TYPE;
        wCANTIDAD_RESPUESTAS_INSERTADAS INTEGER := 0;
    BEGIN
        -- VALIDACIÓN DE QUE LA PRUEBA EXISTE
        PERFORM 1 FROM TAB_PRUEBA WHERE ID_PRUEBA = wID_PRUEBA;
        IF NOT FOUND THEN
            RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'La prueba no existe');
            RETURN RETORNO;
        END IF;

        -- VALIDACIÓN DE QUE EL ESTUDIANTE EXISTE
        PERFORM 1 FROM TAB_ESTUDIANTE WHERE ID_ESTUDIANTE = wID_ESTUDIANTE;
        IF NOT FOUND THEN
            RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'El estudiante no existe');
            RETURN RETORNO;
        END IF;

        --VALIDAR DE QUE NO EXISTAN RESPUESTAS REGISTRADAS
        PERFORM 1 FROM TAB_PRUEBA_RESPUESTAS_ESTUDIANTE WHERE ID_PRUEBA = wID_PRUEBA AND ID_ESTUDIANTE = wID_ESTUDIANTE;
        IF FOUND THEN
            RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'Ya se registraron respuestas para la prueba');
            RETURN RETORNO;
        END IF;

        -- Bucle para procesar las preguntas y opciones del JSON
        FOR wID_PREGUNTA, wID_OPCION IN (
            SELECT 
                (OPCION ->> 'idPregunta')::INTEGER AS idPregunta, 
                (OPCION ->> 'idOpcion')::INTEGER AS idOpcion 
            FROM json_array_elements(PREGUNTAS_OPCIONES) AS OPCION
        ) LOOP
            RAISE NOTICE 'Procesando idPregunta: %, idOpcion: %', wID_PREGUNTA, wID_OPCION;

            -- VERIFICAR QUE LA RESPUESTA NO ESTÉ YA REGISTRADA
            PERFORM 1 FROM TAB_PRUEBA_RESPUESTAS_ESTUDIANTE 
            WHERE ID_PRUEBA = wID_PRUEBA 
              AND ID_ESTUDIANTE = wID_ESTUDIANTE 
              AND ID_RESPUESTA_ESTUDIANTE = wID_OPCION 
              AND ID_PREGUNTA = wID_PREGUNTA;
            
            IF NOT FOUND THEN
                -- REGISTRAR LA RESPUESTA DE LA PREGUNTA
                INSERT INTO TAB_PRUEBA_RESPUESTAS_ESTUDIANTE(ID_PRUEBA, ID_ESTUDIANTE, ID_PREGUNTA, ID_RESPUESTA_ESTUDIANTE) 
                VALUES(wID_PRUEBA, wID_ESTUDIANTE, wID_PREGUNTA, wID_OPCION);
                wCANTIDAD_RESPUESTAS_INSERTADAS := wCANTIDAD_RESPUESTAS_INSERTADAS + 1;
                RAISE NOTICE 'Respuesta registrada: idPregunta: %, idOpcion: %', wID_PREGUNTA, wID_OPCION;
            ELSE
                RAISE NOTICE 'Respuesta ya registrada: idPregunta: %, idOpcion: %', wID_PREGUNTA, wID_OPCION;
            END IF;
        END LOOP;

        --finalizar la prueba siempre y cuando se hayan registrado todas las respuestas
        IF wCANTIDAD_RESPUESTAS_INSERTADAS = (SELECT COUNT(*) FROM json_array_elements(PREGUNTAS_OPCIONES)) THEN
            PERFORM FUN_REGISTRAR_FECHA_FIN_PRUEBA_ESTUDIANTE(wID_PRUEBA, wID_ESTUDIANTE);
        END IF;
        -- Retornar el resultado
        RETORNO := json_build_object('CODIGO', 200, 'MENSAJE', 'Respuestas registradas exitosamente', 'CANTIDAD_RESPUESTAS_INSERTADAS', wCANTIDAD_RESPUESTAS_INSERTADAS);
        RETURN RETORNO;
    END;
$$ LANGUAGE plpgsql;




--FUNCION QUE ME RETORNA EN UN JSON LOS DATOS DE LA PRUEBA PRESENTADA POR EL ESTUDIANTE USANDO EL ID_PRUEBA Y EL ID_ESTUDIANTE
CREATE OR REPLACE FUNCTION FUN_OBTENER_PRUEBA_PRESENTADA_ESTUDIANTE_RESULTADOS_JSON(
    wID_PRUEBA TAB_PRUEBA.ID_PRUEBA%TYPE,
    wID_ESTUDIANTE TAB_ESTUDIANTE.ID_ESTUDIANTE%TYPE
) RETURNS JSON AS
$$
    DECLARE
        RETORNO JSON;
        DATOS JSON;
        TIEMPO_TOTAL_PRUEBA_MINUTOS_ESTUDIANTE INTEGER;
        PREGUNTAS_ACERTADAS INTEGER;
        PREGUNTAS_ERRADAS INTEGER;
        PREGUNTAS_SIN_RESPONDER INTEGER;
        PUNTAJE_OBTENIDO INTEGER;
        NUMERO_DE_AREAS_EVALUADAS_EN_LA_PRUEBA INTEGER;
        PORCENTAJE_ASIERTO_AREAS_EVALUADAS JSON;
        PROMEDIO_TIEMPO_RESPUESTA_PREGUNTA DECIMAL (10,2);
        DATOS_FINAL JSON;
    BEGIN
        --OBTENER LOS DATOS DE LA PRUEBA PRESENTADA POR EL ESTUDIANTE
        -- DATOS: DE LA TABLA TAB_PRUEBA: NOM_PRUEBA, DURACION_PRUEBA_MINUTOS,NUMERO_PREGUNTAS
        -- DATOS: DE LA TABLA TAB_PRUEBA_ESTUDIANTE: FECHA_PRUEBA_INICIO_ESTUDIANTE, FECHA_PRUEBA_FIN_ESTUDIANTE 
        DATOS := (SELECT json_build_object('ID_PRUEBA', P.ID_PRUEBA, 'NOM_PRUEBA', P.NOM_PRUEBA, 'DURACION_PRUEBA_MINUTOS', P.DURACION_PRUEBA_MINUTOS, 'NUMERO_PREGUNTAS', P.NUMERO_PREGUNTAS, 'FECHA_PRUEBA_INICIO_ESTUDIANTE', PE.FECHA_PRUEBA_INICIO_ESTUDIANTE, 'FECHA_PRUEBA_FIN_ESTUDIANTE', PE.FECHA_PRUEBA_FIN_ESTUDIANTE)
        FROM TAB_PRUEBA P
        JOIN TAB_PRUEBA_ESTUDIANTE PE ON P.ID_PRUEBA = PE.ID_PRUEBA
        WHERE P.ID_PRUEBA = wID_PRUEBA AND PE.ID_ESTUDIANTE = wID_ESTUDIANTE);
       
        --VALIDAR SI SE OBTUVIERON DATOS
        IF DATOS IS NULL THEN
            RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'No se encontraron pruebas presentadas por el estudiante');
            RETURN RETORNO;
        ELSE
            -- DATOS A CALCULAR : TIEMPO_TOTAL_PRUEBA_MINUTOS, PREGUNTAS_ACERTADAS, PREGUNTAS_ERRADAS, PREGUNTAS_SIN_RESPONDER, PUNTAJE_OBTENIDO, NUMERO_DE_AREAS_EVALUADAS_EN_LA_PRUEBA, PORCENTAJE_ASIERTO_AREAS_EVALUADAS, PROMEDIO_TIEMPO_RESPUESTA_PREGUNTA
            -- CALCULAR EL TIEMPO TOTAL DE LA PRUEBA EN MINUTOS CON RESPECTO A LO QUE SE DEMORO EL ESTUDIANTE EN REALIZARLA
            SELECT EXTRACT(EPOCH FROM (PE.FECHA_PRUEBA_FIN_ESTUDIANTE - PE.FECHA_PRUEBA_INICIO_ESTUDIANTE)) / 60 INTO TIEMPO_TOTAL_PRUEBA_MINUTOS_ESTUDIANTE
            FROM TAB_PRUEBA_ESTUDIANTE PE
            WHERE PE.ID_PRUEBA = wID_PRUEBA AND PE.ID_ESTUDIANTE = wID_ESTUDIANTE;
            --CALCULAR EL NUMERO DE PREGUNTAS ACERTADAS POR EL ESTUDIANTE
            SELECT COUNT(*) INTO PREGUNTAS_ACERTADAS
            FROM TAB_PRUEBA_RESPUESTAS_ESTUDIANTE PRE
            JOIN TAB_OPCIONES_PREGUNTA OP ON PRE.ID_RESPUESTA_ESTUDIANTE = OP.ID_OPCION
            WHERE PRE.ID_PRUEBA = wID_PRUEBA AND PRE.ID_ESTUDIANTE = wID_ESTUDIANTE AND OP.ES_CORRECTA = TRUE;
            --CALCULAR EL NUMERO DE PREGUNTAS ERRADAS POR EL ESTUDIANTE
            SELECT COUNT(*) INTO PREGUNTAS_ERRADAS
            FROM TAB_PRUEBA_RESPUESTAS_ESTUDIANTE PRE
            JOIN TAB_OPCIONES_PREGUNTA OP ON PRE.ID_RESPUESTA_ESTUDIANTE = OP.ID_OPCION
            WHERE PRE.ID_PRUEBA = wID_PRUEBA AND PRE.ID_ESTUDIANTE = wID_ESTUDIANTE AND OP.ES_CORRECTA = FALSE;
            --CALCULAR EL NUMERO DE PREGUNTAS SIN RESPONDER POR EL ESTUDIANTE
            SELECT COUNT(*) INTO PREGUNTAS_SIN_RESPONDER
            FROM TAB_PRUEBA_PREGUNTAS PP
            WHERE PP.ID_PRUEBA = wID_PRUEBA AND PP.ID_PREGUNTA NOT IN (SELECT ID_PREGUNTA FROM TAB_PRUEBA_RESPUESTAS_ESTUDIANTE WHERE ID_PRUEBA = wID_PRUEBA AND ID_ESTUDIANTE = wID_ESTUDIANTE);
            --CALCULAR EL PUNTAJE OBTENIDO POR EL ESTUDIANTE SE CALCULA CON EL NUMERO DE PREGUNTAS ACERTADAS / NUMERO DE PREGUNTAS DE LA PRUEBA * 100
            SELECT (PREGUNTAS_ACERTADAS / (SELECT NUMERO_PREGUNTAS FROM TAB_PRUEBA WHERE ID_PRUEBA = wID_PRUEBA)) * 100 INTO PUNTAJE_OBTENIDO;
            -- CALCULAR EL NUMERO DE AREAS EVALUADAS EN LA PRUEBA
            SELECT COUNT(DISTINCT AE.ID_AREA_EVALUAR) INTO NUMERO_DE_AREAS_EVALUADAS_EN_LA_PRUEBA
            FROM TAB_AREAS_EVALUAR AE
            JOIN TAB_TEMAS_AREAS TA ON AE.ID_AREA_EVALUAR = TA.ID_AREA_EVALUAR
            JOIN TAB_PREGUNTA_TEMAS PT ON TA.ID_TEMA_AREA = PT.ID_TEMA_AREA
            JOIN TAB_PREGUNTA P ON PT.ID_PREGUNTA = P.ID_PREGUNTA
            JOIN TAB_PRUEBA_PREGUNTAS PP ON P.ID_PREGUNTA = PP.ID_PREGUNTA
            WHERE PP.ID_PRUEBA = wID_PRUEBA;
            -- CALCULAR EL NUMERO DE AREAS EVALUADAS EN LA PRUEBA
            PORCENTAJE_ASIERTO_AREAS_EVALUADAS := (
                SELECT json_agg(
                    json_build_object(
                        'NOMBRE_AREA', AE.NOM_AREA_EVALUAR,
                        'PORCENTAJE_ACIERTO', (
                            SELECT CASE 
                                WHEN (
                                    SELECT COUNT(*) 
                                    FROM TAB_PRUEBA_RESPUESTAS_ESTUDIANTE PRE
                                    JOIN TAB_OPCIONES_PREGUNTA OP ON PRE.ID_RESPUESTA_ESTUDIANTE = OP.ID_OPCION
                                    JOIN TAB_PREGUNTA P ON PRE.ID_PREGUNTA = P.ID_PREGUNTA
                                    JOIN TAB_PREGUNTA_TEMAS PT ON P.ID_PREGUNTA = PT.ID_PREGUNTA
                                    JOIN TAB_TEMAS_AREAS TA ON PT.ID_TEMA_AREA = TA.ID_TEMA_AREA
                                    WHERE PRE.ID_PRUEBA = wID_PRUEBA
                                    AND PRE.ID_ESTUDIANTE = wID_ESTUDIANTE
                                    AND TA.ID_AREA_EVALUAR = AE.ID_AREA_EVALUAR
                                ) = 0 THEN 0
                                ELSE (
                                    (
                                        SELECT COUNT(*) 
                                        FROM TAB_PRUEBA_RESPUESTAS_ESTUDIANTE PRE
                                        JOIN TAB_OPCIONES_PREGUNTA OP ON PRE.ID_RESPUESTA_ESTUDIANTE = OP.ID_OPCION
                                        JOIN TAB_PREGUNTA P ON PRE.ID_PREGUNTA = P.ID_PREGUNTA
                                        JOIN TAB_PREGUNTA_TEMAS PT ON P.ID_PREGUNTA = PT.ID_PREGUNTA
                                        JOIN TAB_TEMAS_AREAS TA ON PT.ID_TEMA_AREA = TA.ID_TEMA_AREA
                                        WHERE PRE.ID_PRUEBA = wID_PRUEBA
                                        AND PRE.ID_ESTUDIANTE = wID_ESTUDIANTE
                                        AND OP.ES_CORRECTA = TRUE
                                        AND TA.ID_AREA_EVALUAR = AE.ID_AREA_EVALUAR
                                    )::FLOAT / (
                                        SELECT COUNT(*) 
                                        FROM TAB_PRUEBA_RESPUESTAS_ESTUDIANTE PRE
                                        JOIN TAB_OPCIONES_PREGUNTA OP ON PRE.ID_RESPUESTA_ESTUDIANTE = OP.ID_OPCION
                                        JOIN TAB_PREGUNTA P ON PRE.ID_PREGUNTA = P.ID_PREGUNTA
                                        JOIN TAB_PREGUNTA_TEMAS PT ON P.ID_PREGUNTA = PT.ID_PREGUNTA
                                        JOIN TAB_TEMAS_AREAS TA ON PT.ID_TEMA_AREA = TA.ID_TEMA_AREA
                                        WHERE PRE.ID_PRUEBA = wID_PRUEBA
                                        AND PRE.ID_ESTUDIANTE = wID_ESTUDIANTE
                                        AND TA.ID_AREA_EVALUAR = AE.ID_AREA_EVALUAR
                                    ) * 100
                                )
                            END
                        )
                    )
                )
                FROM TAB_AREAS_EVALUAR AE
                WHERE EXISTS (
                    SELECT 1
                    FROM TAB_PRUEBA_RESPUESTAS_ESTUDIANTE PRE
                    JOIN TAB_OPCIONES_PREGUNTA OP ON PRE.ID_RESPUESTA_ESTUDIANTE = OP.ID_OPCION
                    JOIN TAB_PREGUNTA P ON PRE.ID_PREGUNTA = P.ID_PREGUNTA
                    JOIN TAB_PREGUNTA_TEMAS PT ON P.ID_PREGUNTA = PT.ID_PREGUNTA
                    JOIN TAB_TEMAS_AREAS TA ON PT.ID_TEMA_AREA = TA.ID_TEMA_AREA
                    WHERE PRE.ID_PRUEBA = wID_PRUEBA
                    AND PRE.ID_ESTUDIANTE = wID_ESTUDIANTE
                    AND TA.ID_AREA_EVALUAR = AE.ID_AREA_EVALUAR
                )
            );
            --CALCULAR EL PROMEDIO DE TIEMPO DE RESPUESTA DE LAS PREGUNTAS SE CALCULA: TIEMPO QUE DEMORO EL ESTUDIANTE EN REALIZAR LA PRUEBA /NUMERO DE PREGUNTAS RESPONDIDAS POR EL ESTUDIANTE
            SELECT (EXTRACT(EPOCH FROM (PE.FECHA_PRUEBA_FIN_ESTUDIANTE - PE.FECHA_PRUEBA_INICIO_ESTUDIANTE)) / 60) / (SELECT COUNT(*) FROM TAB_PRUEBA_RESPUESTAS_ESTUDIANTE WHERE ID_PRUEBA = wID_PRUEBA AND ID_ESTUDIANTE = wID_ESTUDIANTE) INTO PROMEDIO_TIEMPO_RESPUESTA_PREGUNTA
            FROM TAB_PRUEBA_ESTUDIANTE PE
            WHERE PE.ID_PRUEBA = wID_PRUEBA AND PE.ID_ESTUDIANTE = wID_ESTUDIANTE;
            -- CONCATENAR TODOS LOS RESULTADOS PARA ENVIARLOS EN UNA VARIABLE JSON
            DATOS_FINAL := json_build_object('DATOS_PRUEBA', DATOS, 'TIEMPO_TOTAL_PRUEBA_MINUTOS_ESTUDIANTE', TIEMPO_TOTAL_PRUEBA_MINUTOS_ESTUDIANTE, 'PREGUNTAS_ACERTADAS', PREGUNTAS_ACERTADAS, 'PREGUNTAS_ERRADAS', PREGUNTAS_ERRADAS, 'PREGUNTAS_SIN_RESPONDER', PREGUNTAS_SIN_RESPONDER, 'PUNTAJE_OBTENIDO', PUNTAJE_OBTENIDO, 'NUMERO_DE_AREAS_EVALUADAS_EN_LA_PRUEBA', NUMERO_DE_AREAS_EVALUADAS_EN_LA_PRUEBA, 'PORCENTAJE_ASIERTO_AREAS_EVALUADAS', PORCENTAJE_ASIERTO_AREAS_EVALUADAS, 'PROMEDIO_TIEMPO_RESPUESTA_PREGUNTA', PROMEDIO_TIEMPO_RESPUESTA_PREGUNTA);
            -- RETORNAR EL RESULTADO
            RETORNO := json_build_object
            (
                'CODIGO', 200,
                'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 200),
                'DATOS', DATOS_FINAL
            );
            RETURN RETORNO;
        END IF;
    END;
$$
LANGUAGE plpgsql;
