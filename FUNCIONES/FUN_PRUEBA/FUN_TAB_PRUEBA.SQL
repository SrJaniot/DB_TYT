--FUNCIONES TRANSACCIONALES Y DE INSERCION DE DATOS PARA LA TABLA TAB_PRUEBA------------------------------------------------------------------------------------------------------------
--FUNCION PARA VALIDAR LOS DATOS A INSERTAR EN LA TABLA PRUEBA
CREATE OR REPLACE FUNCTION FUN_VALIDAR_DATOS_PRUEBA(wNOM_PRUEBA TAB_PRUEBA.NOM_PRUEBA%TYPE,
                            wDESCRIPCION_PRUEBA TAB_PRUEBA.DESCRIPCION_PRUEBA%TYPE) RETURNS INTEGER AS
$$
    DECLARE
        RETORNO INTEGER;
    BEGIN
        --VALIDACION DEL PARAMETRO wNOM_PRUEBA TIENE QUE SER MAYOR A 3 CARACTERES Y NO NULO
        IF LENGTH(wNOM_PRUEBA) < 3 OR wNOM_PRUEBA IS NULL THEN
            RETORNO := 5001;
            RETURN RETORNO;
        --VALIDACION DEL PARAMETRO wDESCRIPCION_PRUEBA TIENE QUE SER MAYOR A 3 CARACTERES Y NO NULO
        ELSIF LENGTH(wDESCRIPCION_PRUEBA) < 3 OR wDESCRIPCION_PRUEBA IS NULL THEN
            RETORNO := 5002;
            RETURN RETORNO;
        --EVALUAR SI LA PRUEBA YA EXISTE
        --CONVERTIR EL NOMBRE A MAYUSCULAS
        ELSEIF EXISTS(SELECT * FROM TAB_PRUEBA WHERE UPPER(NOM_PRUEBA) = UPPER(wNOM_PRUEBA)) THEN
            RETORNO := 5003;
            RETURN RETORNO;
        ELSE
            RETORNO := 200;
            RETURN RETORNO;
        END IF;        
    END;
$$
LANGUAGE plpgsql;

--FUNCION PARA INSERTAR DATOS EN LA TABLA PRUEBA
CREATE OR REPLACE FUNCTION FUN_INSERTAR_PRUEBA(wNOM_PRUEBA TAB_PRUEBA.NOM_PRUEBA%TYPE,
                            wDESCRIPCION_PRUEBA TAB_PRUEBA.DESCRIPCION_PRUEBA%TYPE) RETURNS INTEGER AS
$$
    DECLARE
        RETORNO INTEGER;
        VALIDACION INTEGER;
        ULTIMOID INTEGER;
    BEGIN
        --VALIDAR LOS DATOS A INSERTAR
        VALIDACION := FUN_VALIDAR_DATOS_PRUEBA(wNOM_PRUEBA,wDESCRIPCION_PRUEBA);
        --SI LA VALIDACION ES CORRECTA INSERTAR LOS DATOS
        IF VALIDACION = 200 THEN
            --GENERAR ID AUTOINCREMENTABLE USANDO LA FUNCION funcion_Retorna_ultmoid
            SELECT INTO ULTIMOID funcion_Retorna_ultmoid('TAB_PRUEBA','ID_PRUEBA');
            --CONVERTIR EL NOMBRE A MAYUSCULAS
            wNOM_PRUEBA := UPPER(wNOM_PRUEBA);
            --INSERTAR DATOS EN LA TABLA PRUEBA
            INSERT INTO TAB_PRUEBA VALUES(ULTIMOID,wNOM_PRUEBA,wDESCRIPCION_PRUEBA);
            IF FOUND THEN
                RETORNO := 200;
                RETURN RETORNO;
            ELSE
                RETORNO := 1;
                RETURN RETORNO;
            END IF;
        ELSE
            RETURN VALIDACION;
        END IF;
    END;
$$
LANGUAGE plpgsql;


--FUNCION PARA INSERTAR UNA PRUEBA Y QUE RETORNE UN JSON CON EL RESULTADO, MENSAJE Y ID DE LA PRUEBA
CREATE OR REPLACE FUNCTION FUN_INSERTAR_PRUEBA_JSON(wNOM_PRUEBA TAB_PRUEBA.NOM_PRUEBA%TYPE,
                            wDESCRIPCION_PRUEBA TAB_PRUEBA.DESCRIPCION_PRUEBA%TYPE) RETURNS JSON AS
$$
    DECLARE
        RETORNO JSON;
        wVALIDAR INTEGER;
        ULTIMOID INTEGER;
    BEGIN
        --VALIDACION DE LOS DATOS A INSERTAR
        wVALIDAR := FUN_VALIDAR_DATOS_PRUEBA(wNOM_PRUEBA, wDESCRIPCION_PRUEBA);
        IF wVALIDAR <> 200 THEN
            RETORNO := json_build_object('CODIGO',wVALIDAR,'MENSAJE',(SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = wVALIDAR));
            RETURN RETORNO;
        ELSE
            --INSERCION DE LOS DATOS
            --OBTENER EL ULTIMO ID DE LA TABLA PRUEBA
            SELECT INTO ULTIMOID funcion_Retorna_ultmoid('TAB_PRUEBA','ID_PRUEBA');
            INSERT INTO TAB_PRUEBA(ID_PRUEBA, NOM_PRUEBA, DESCRIPCION_PRUEBA)
            VALUES(ULTIMOID, wNOM_PRUEBA, wDESCRIPCION_PRUEBA);
            --VERIFICAR SI SE REALIZO LA INSERCION
            IF FOUND THEN
                RETORNO := json_build_object('CODIGO',200,'MENSAJE',(SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 200),'DATOS',json_build_object('ID_PRUEBA',ULTIMOID));
                RETURN RETORNO;
            ELSE
                RETORNO := json_build_object('CODIGO', 1,'MENSAJE',(SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 1)); 
                RETURN RETORNO;
            END IF;
        END IF;
    END;
$$
LANGUAGE plpgsql;
-- FUNCIÓN PARA INSERTAR UNA PRUEBA Y QUE RETORNE UN JSON CON EL RESULTADO, MENSAJE Y ID DE LA PRUEBA TAMBIÉN VINCULAR PREGUNTAS A LA PRUEBA DE FORMA RANDOM Y AUTOMÁTICA TENIENDO EN CUENTA LAS DIFERENTES ÁREAS A EVALUAR
CREATE OR REPLACE FUNCTION FUN_INSERTAR_PRUEBA_RANDOM_JSON(wNOM_PRUEBA TAB_PRUEBA.NOM_PRUEBA%TYPE,
                                                            wDESCRIPCION_PRUEBA TAB_PRUEBA.DESCRIPCION_PRUEBA%TYPE,
                                                            wID_AREA_EVALUAR TAB_AREA_EVALUAR.ID_AREA_EVALUAR%TYPE,
                                                            wCANTIDAD_PREGUNTAS INTEGER) RETURNS JSON AS
$$
    DECLARE
        RETORNO JSON;
        wVALIDAR INTEGER;
        ULTIMOID INTEGER;
        wID_PREGUNTA_RANDOM INTEGER;
        wCANTIDAD_PREGUNTAS_INSERTADAS INTEGER;
        wCANTIDAD_PREGUNTAS_TOTAL_AREA INTEGER;
    BEGIN
        -- VALIDACIÓN DE LOS DATOS A INSERTAR
        wVALIDAR := FUN_VALIDAR_DATOS_PRUEBA(wNOM_PRUEBA, wDESCRIPCION_PRUEBA);
        IF wVALIDAR <> 200 THEN
            RETORNO := json_build_object('CODIGO', wVALIDAR, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = wVALIDAR));
            RETURN RETORNO;
        ELSE
            -- OBTENER EL ÚLTIMO ID DE LA TABLA PRUEBA
            SELECT INTO ULTIMOID funcion_Retorna_ultmoid('TAB_PRUEBA', 'ID_PRUEBA');

            -- INSERCIÓN DE LOS DATOS EN TAB_PRUEBA
            INSERT INTO TAB_PRUEBA(ID_PRUEBA, NOM_PRUEBA, DESCRIPCION_PRUEBA)
            VALUES(ULTIMOID, wNOM_PRUEBA, wDESCRIPCION_PRUEBA);

            -- VERIFICAR SI SE REALIZÓ LA INSERCIÓN
            IF FOUND THEN
                -- OBTENER LA CANTIDAD DE PREGUNTAS EN EL ÁREA A EVALUAR A TRAVÉS DE LOS TEMAS
                SELECT INTO wCANTIDAD_PREGUNTAS_TOTAL_AREA COUNT(*)
                FROM TAB_PREGUNTA P
                JOIN TAB_PREGUNTA_TEMAS PT ON P.ID_PREGUNTA = PT.ID_PREGUNTA
                JOIN TAB_TEMAS_AREAS TA ON PT.ID_TEMA_AREA = TA.ID_TEMA_AREA
                WHERE TA.ID_AREA_EVALUAR = wID_AREA_EVALUAR;

                -- VERIFICAR QUE HAY SUFICIENTES PREGUNTAS DISPONIBLES
                IF wCANTIDAD_PREGUNTAS > wCANTIDAD_PREGUNTAS_TOTAL_AREA THEN
                    RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'No hay suficientes preguntas disponibles en el área evaluada');
                    RETURN RETORNO;
                END IF;

                -- INSERTAR LAS PREGUNTAS DE FORMA RANDOM
                wCANTIDAD_PREGUNTAS_INSERTADAS := 0;

                WHILE wCANTIDAD_PREGUNTAS_INSERTADAS < wCANTIDAD_PREGUNTAS LOOP
                    -- OBTENER UNA PREGUNTA RANDOM QUE AÚN NO HAYA SIDO INSERTADA
                    SELECT INTO wID_PREGUNTA_RANDOM P.ID_PREGUNTA
                    FROM TAB_PREGUNTA P
                    JOIN TAB_PREGUNTA_TEMAS PT ON P.ID_PREGUNTA = PT.ID_PREGUNTA
                    JOIN TAB_TEMAS_AREAS TA ON PT.ID_TEMA_AREA = TA.ID_TEMA_AREA
                    WHERE TA.ID_AREA_EVALUAR = wID_AREA_EVALUAR
                    AND P.ID_PREGUNTA NOT IN (SELECT ID_PREGUNTA FROM TAB_PRUEBA_PREGUNTA WHERE ID_PRUEBA = ULTIMOID)
                    ORDER BY RANDOM() LIMIT 1;

                    -- INSERTAR LA PREGUNTA EN LA PRUEBA
                    INSERT INTO TAB_PRUEBA_PREGUNTA(ID_PRUEBA, ID_PREGUNTA) 
                    VALUES(ULTIMOID, wID_PREGUNTA_RANDOM);
                    wCANTIDAD_PREGUNTAS_INSERTADAS := wCANTIDAD_PREGUNTAS_INSERTADAS + 1;
                END LOOP;

                -- RETORNAR EL RESULTADO EXITOSO
                RETORNO := json_build_object('CODIGO', 200, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 200), 'DATOS', json_build_object('ID_PRUEBA', ULTIMOID));
                RETURN RETORNO;
            ELSE
                -- RETORNAR ERROR DE INSERCIÓN
                RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 1));
                RETURN RETORNO;
            END IF;
        END IF;
    END;
$$
LANGUAGE plpgsql;


-- FUNCIÓN PARA INSERTAR UNA PRUEBA Y QUE RETORNE UN JSON CON EL RESULTADO, MENSAJE Y ID DE LA PRUEBA TAMBIÉN VINCULAR PREGUNTAS A LA PRUEBA DE FORMA RANDOM Y AUTOMÁTICA TENIENDO EN CUENTA LOS DIFERENTES TEMAS A EVALUAR
CREATE OR REPLACE FUNCTION FUN_INSERTAR_PRUEBA_RANDOM_JSON(
    wNOM_PRUEBA TAB_PRUEBA.NOM_PRUEBA%TYPE,
    wDESCRIPCION_PRUEBA TAB_PRUEBA.DESCRIPCION_PRUEBA%TYPE,
    wID_TEMA_AREA TAB_TEMAS_AREAS.ID_TEMA_AREA%TYPE,
    wCANTIDAD_PREGUNTAS INTEGER
) RETURNS JSON AS
$$
    DECLARE
        RETORNO JSON;
        wVALIDAR INTEGER;
        ULTIMOID INTEGER;
        wID_PREGUNTA_RANDOM INTEGER;
        wCANTIDAD_PREGUNTAS_INSERTADAS INTEGER;
        wCANTIDAD_PREGUNTAS_TOTAL_TEMA INTEGER;
    BEGIN
        -- VALIDACIÓN DE LOS DATOS A INSERTAR
        wVALIDAR := FUN_VALIDAR_DATOS_PRUEBA(wNOM_PRUEBA, wDESCRIPCION_PRUEBA);
        IF wVALIDAR <> 200 THEN
            RETORNO := json_build_object('CODIGO', wVALIDAR, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = wVALIDAR));
            RETURN RETORNO;
        ELSE
            -- OBTENER EL ÚLTIMO ID DE LA TABLA PRUEBA
            SELECT INTO ULTIMOID funcion_Retorna_ultmoid('TAB_PRUEBA', 'ID_PRUEBA');

            -- INSERCIÓN DE LOS DATOS EN TAB_PRUEBA
            INSERT INTO TAB_PRUEBA(ID_PRUEBA, NOM_PRUEBA, DESCRIPCION_PRUEBA)
            VALUES(ULTIMOID, wNOM_PRUEBA, wDESCRIPCION_PRUEBA);

            -- VERIFICAR SI SE REALIZÓ LA INSERCIÓN
            IF FOUND THEN
                -- OBTENER LA CANTIDAD DE PREGUNTAS EN EL TEMA A EVALUAR
                SELECT INTO wCANTIDAD_PREGUNTAS_TOTAL_TEMA COUNT(*)
                FROM TAB_PREGUNTA P
                JOIN TAB_PREGUNTA_TEMAS PT ON P.ID_PREGUNTA = PT.ID_PREGUNTA
                WHERE PT.ID_TEMA_AREA = wID_TEMA_AREA;

                -- VERIFICAR QUE HAY SUFICIENTES PREGUNTAS DISPONIBLES
                IF wCANTIDAD_PREGUNTAS > wCANTIDAD_PREGUNTAS_TOTAL_TEMA THEN
                    RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'No hay suficientes preguntas disponibles en el tema evaluado');
                    RETURN RETORNO;
                END IF;

                -- INSERTAR LAS PREGUNTAS DE FORMA RANDOM
                wCANTIDAD_PREGUNTAS_INSERTADAS := 0;

                WHILE wCANTIDAD_PREGUNTAS_INSERTADAS < wCANTIDAD_PREGUNTAS LOOP
                    -- OBTENER UNA PREGUNTA RANDOM QUE AÚN NO HAYA SIDO INSERTADA
                    SELECT INTO wID_PREGUNTA_RANDOM P.ID_PREGUNTA
                    FROM TAB_PREGUNTA P
                    JOIN TAB_PREGUNTA_TEMAS PT ON P.ID_PREGUNTA = PT.ID_PREGUNTA
                    WHERE PT.ID_TEMA_AREA = wID_TEMA_AREA
                    AND P.ID_PREGUNTA NOT IN (SELECT ID_PREGUNTA FROM TAB_PRUEBA_PREGUNTA WHERE ID_PRUEBA = ULTIMOID)
                    ORDER BY RANDOM() LIMIT 1;

                    -- INSERTAR LA PREGUNTA EN LA PRUEBA
                    INSERT INTO TAB_PRUEBA_PREGUNTA(ID_PRUEBA, ID_PREGUNTA) 
                    VALUES(ULTIMOID, wID_PREGUNTA_RANDOM);
                    wCANTIDAD_PREGUNTAS_INSERTADAS := wCANTIDAD_PREGUNTAS_INSERTADAS + 1;
                END LOOP;

                -- RETORNAR EL RESULTADO EXITOSO
                RETORNO := json_build_object('CODIGO', 200, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 200), 'DATOS', json_build_object('ID_PRUEBA', ULTIMOID));
                RETURN RETORNO;
            ELSE
                -- RETORNAR ERROR DE INSERCIÓN
                RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 1));
                RETURN RETORNO;
            END IF;
        END IF;
    END;
$$
LANGUAGE plpgsql;





-- FUNCIÓN PARA VINCULAR PREGUNTAS ALEATORIAS A UNA PRUEBA EXISTENTE BASADA EN ÁREAS A EVALUAR
CREATE OR REPLACE FUNCTION FUN_VINCULAR_PREGUNTAS_A_PRUEBA(
    wID_PRUEBA TAB_PRUEBA.ID_PRUEBA%TYPE,
    wID_AREA_EVALUAR TAB_AREAS_EVALUAR.ID_AREA_EVALUAR%TYPE,
    wCANTIDAD_PREGUNTAS INTEGER
) RETURNS JSON AS
$$
    DECLARE
        RETORNO JSON;
        wVALIDAR INTEGER;
        wID_PREGUNTA_RANDOM INTEGER;
        wCANTIDAD_PREGUNTAS_INSERTADAS INTEGER;
        wCANTIDAD_PREGUNTAS_TOTAL_AREA INTEGER;
    BEGIN
        -- VALIDACIÓN DE QUE LA PRUEBA EXISTE
        PERFORM 1 FROM TAB_PRUEBA WHERE ID_PRUEBA = wID_PRUEBA;
        IF NOT FOUND THEN
            RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'La prueba no existe');
            RETURN RETORNO;
        END IF;

        -- OBTENER LA CANTIDAD DE PREGUNTAS EN EL ÁREA A EVALUAR
        SELECT INTO wCANTIDAD_PREGUNTAS_TOTAL_AREA COUNT(*)
        FROM TAB_PREGUNTA P
        JOIN TAB_PREGUNTA_TEMAS PT ON P.ID_PREGUNTA = PT.ID_PREGUNTA
        JOIN TAB_TEMAS_AREAS TA ON PT.ID_TEMA_AREA = TA.ID_TEMA_AREA
        WHERE TA.ID_AREA_EVALUAR = wID_AREA_EVALUAR;

        -- VERIFICAR QUE HAY SUFICIENTES PREGUNTAS DISPONIBLES
        IF wCANTIDAD_PREGUNTAS > wCANTIDAD_PREGUNTAS_TOTAL_AREA THEN
            RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'No hay suficientes preguntas disponibles en el área evaluada');
            RETURN RETORNO;
        END IF;

        -- VINCULAR LAS PREGUNTAS DE FORMA RANDOM
        wCANTIDAD_PREGUNTAS_INSERTADAS := 0;

        WHILE wCANTIDAD_PREGUNTAS_INSERTADAS < wCANTIDAD_PREGUNTAS LOOP
            -- OBTENER UNA PREGUNTA RANDOM QUE AÚN NO HAYA SIDO VINCULADA A LA PRUEBA
            SELECT INTO wID_PREGUNTA_RANDOM P.ID_PREGUNTA
            FROM TAB_PREGUNTA P
            JOIN TAB_PREGUNTA_TEMAS PT ON P.ID_PREGUNTA = PT.ID_PREGUNTA
            JOIN TAB_TEMAS_AREAS TA ON PT.ID_TEMA_AREA = TA.ID_TEMA_AREA
            WHERE TA.ID_AREA_EVALUAR = wID_AREA_EVALUAR
            AND P.ID_PREGUNTA NOT IN (SELECT ID_PREGUNTA FROM TAB_PRUEBA_PREGUNTA WHERE ID_PRUEBA = wID_PRUEBA)
            ORDER BY RANDOM() LIMIT 1;

            -- VINCULAR LA PREGUNTA A LA PRUEBA
            INSERT INTO TAB_PRUEBA_PREGUNTA(ID_PRUEBA, ID_PREGUNTA) 
            VALUES(wID_PRUEBA, wID_PREGUNTA_RANDOM);
            wCANTIDAD_PREGUNTAS_INSERTADAS := wCANTIDAD_PREGUNTAS_INSERTADAS + 1;
        END LOOP;

        -- RETORNAR EL RESULTADO EXITOSO
        RETORNO := json_build_object('CODIGO', 200, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 200), 'DATOS', json_build_object('ID_PRUEBA', wID_PRUEBA));
        RETURN RETORNO;
    END;
$$
LANGUAGE plpgsql;



-- FUNCIÓN PARA VINCULAR PREGUNTAS ALEATORIAS A UNA PRUEBA EXISTENTE BASADA EN TEMAS A EVALUAR
CREATE OR REPLACE FUNCTION FUN_VINCULAR_PREGUNTAS_A_PRUEBA_POR_TEMA(
    wID_PRUEBA TAB_PRUEBA.ID_PRUEBA%TYPE,
    wID_TEMA_AREA TAB_TEMAS_AREAS.ID_TEMA_AREA%TYPE,
    wCANTIDAD_PREGUNTAS INTEGER
) RETURNS JSON AS
$$
    DECLARE
        RETORNO JSON;
        wVALIDAR INTEGER;
        wID_PREGUNTA_RANDOM INTEGER;
        wCANTIDAD_PREGUNTAS_INSERTADAS INTEGER;
        wCANTIDAD_PREGUNTAS_TOTAL_TEMA INTEGER;
    BEGIN
        -- VALIDACIÓN DE QUE LA PRUEBA EXISTE
        PERFORM 1 FROM TAB_PRUEBA WHERE ID_PRUEBA = wID_PRUEBA;
        IF NOT FOUND THEN
            RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'La prueba no existe');
            RETURN RETORNO;
        END IF;

        -- OBTENER LA CANTIDAD DE PREGUNTAS EN EL TEMA A EVALUAR
        SELECT INTO wCANTIDAD_PREGUNTAS_TOTAL_TEMA COUNT(*)
        FROM TAB_PREGUNTA P
        JOIN TAB_PREGUNTA_TEMAS PT ON P.ID_PREGUNTA = PT.ID_PREGUNTA
        WHERE PT.ID_TEMA_AREA = wID_TEMA_AREA;

        -- VERIFICAR QUE HAY SUFICIENTES PREGUNTAS DISPONIBLES
        IF wCANTIDAD_PREGUNTAS > wCANTIDAD_PREGUNTAS_TOTAL_TEMA THEN
            RETORNO := json_build_object('CODIGO', 1, 'MENSAJE', 'No hay suficientes preguntas disponibles en el tema evaluado');
            RETURN RETORNO;
        END IF;

        -- VINCULAR LAS PREGUNTAS DE FORMA RANDOM
        wCANTIDAD_PREGUNTAS_INSERTADAS := 0;

        WHILE wCANTIDAD_PREGUNTAS_INSERTADAS < wCANTIDAD_PREGUNTAS LOOP
            -- OBTENER UNA PREGUNTA RANDOM QUE AÚN NO HAYA SIDO VINCULADA A LA PRUEBA
            SELECT INTO wID_PREGUNTA_RANDOM P.ID_PREGUNTA
            FROM TAB_PREGUNTA P
            JOIN TAB_PREGUNTA_TEMAS PT ON P.ID_PREGUNTA = PT.ID_PREGUNTA
            WHERE PT.ID_TEMA_AREA = wID_TEMA_AREA
            AND P.ID_PREGUNTA NOT IN (SELECT ID_PREGUNTA FROM TAB_PRUEBA_PREGUNTA WHERE ID_PRUEBA = wID_PRUEBA)
            ORDER BY RANDOM() LIMIT 1;

            -- VINCULAR LA PREGUNTA A LA PRUEBA
            INSERT INTO TAB_PRUEBA_PREGUNTA(ID_PRUEBA, ID_PREGUNTA) 
            VALUES(wID_PRUEBA, wID_PREGUNTA_RANDOM);
            wCANTIDAD_PREGUNTAS_INSERTADAS := wCANTIDAD_PREGUNTAS_INSERTADAS + 1;
        END LOOP;

        -- RETORNAR EL RESULTADO EXITOSO
        RETORNO := json_build_object('CODIGO', 200, 'MENSAJE', (SELECT desc_mensaje FROM TAB_MENSAJES WHERE id_mensaje = 200), 'DATOS', json_build_object('ID_PRUEBA', wID_PRUEBA));
        RETURN RETORNO;
    END;
$$
LANGUAGE plpgsql;

